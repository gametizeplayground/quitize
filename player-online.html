<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>Quitize - Join Game</title>
    <link rel="stylesheet" href="playerstyles.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4CAF50">
    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <img src="assets/logo.png" alt="Quitize Logo" class="logo">
        </div>

        <!-- Game Code Entry Screen -->
        <div class="screen active" id="game-code-screen">
            <div class="main-content">
                <div class="mascot-container">
                    <div class="mascot">
                        <img src="assets/mascot.png" alt="Mascot" style="width: 200px; height: 200px;" />
                    </div>
                </div>

                <h1 class="welcome-text">Let's Play!</h1>

                <div class="form-container">
                    <input 
                        type="text" 
                        class="input-field" 
                        id="game-code-input" 
                        placeholder="Game Key"
                        maxlength="8"
                        autocomplete="off"
                    >
                    <button class="enter-button" id="enter-button" onclick="enterGameCode()">
                        Enter
                    </button>
                </div>

                <!-- Messages -->
                <div id="message-container"></div>
            </div>
        </div>

        <!-- Nickname Entry Screen -->
        <div class="screen" id="nickname-screen">
            <div class="main-content">
                <div class="mascot-container">
                    <div class="mascot">
                        <img src="assets/mascot2.png" alt="Mascot" style="width: 150px; height: 200px;" />
                    </div>
                </div>

                <h1 class="welcome-text">What's your name?</h1>

                <div class="form-container">
                    <input 
                        type="text" 
                        class="input-field" 
                        id="nickname-input" 
                        placeholder="Enter your name"
                        maxlength="20"
                        autocomplete="off"
                    >
                    <button class="join-button" id="join-button" onclick="joinGame()">
                        Join to the game!
                    </button>
                </div>

                <!-- Messages -->
                <div id="nickname-message-container"></div>
            </div>
        </div>

        <!-- Waiting Room Screen -->
        <div class="screen" id="waiting-room-screen">
            <div class="main-content">
                <div class="mascot-container">
                    <div class="mascot">
                        <img src="assets/mascot3.png" alt="Mascot">
                    </div>
                </div>
                
                <h1 class="welcome-text">Welcome!<br><span id="player-name-display">Player</span></h1>
                <p class="welcome-subtitle">Spot your name on the screen?</p>
                
                <div class="form-container">
                    <!-- Live Reaction Buttons -->
                    <div class="reaction-buttons">
                        <button class="reaction-btn" onclick="sendReaction('clap')" title="Clap">
                            <img src="assets/livereaction/clap.png" alt="Clap" class="reaction-icon">
                        </button>
                        <button class="reaction-btn" onclick="sendReaction('heart')" title="Heart">
                            <img src="assets/livereaction/heart.png" alt="Heart" class="reaction-icon">
                        </button>
                        <button class="reaction-btn" onclick="sendReaction('confetti')" title="Celebrate">
                            <img src="assets/livereaction/confetti.png" alt="Confetti" class="reaction-icon">
                        </button>
                    </div>
                    
                    <button class="leave-room-btn" onclick="leaveRoom()">
                        Leave the room
                    </button>
                </div>
            </div>
        </div>

        <!-- Loading Screen -->
        <div class="screen" id="loading-screen">
            <div class="loading-screen-content">
                <h1 class="loading-title">Loading...</h1>
            </div>
            
            <div class="player-info">
                <span id="player-name-loading">Player</span>
                <div class="player-score" id="player-score-loading">0</div>
            </div>
        </div>

        <!-- Countdown Screen -->
        <div class="screen" id="countdown-screen">
            <div class="countdown-screen-content">
                <h1 class="quiz-title">Quiz 1</h1>
                <div class="countdown-number" id="countdown-display">10</div>
                <div class="countdown-mascot">
                    <img src="assets/getready_mascot.png" alt="Get Ready Mascot">
                </div>
            </div>

            <div class="player-info">
                <span id="player-name-info">Player</span>
                <div class="player-score" id="player-score-info">0</div>
            </div>
        </div>

        <!-- Question Screen -->
        <div class="screen" id="question-screen">
            <div class="question-screen-content">
                <h1 class="quiz-title">Quiz 1</h1>
                
                <div class="question-options">
                    <button class="option-button option-a" onclick="selectAnswer('A')">
                        A
                    </button>
                    <button class="option-button option-b" onclick="selectAnswer('B')">
                        B
                    </button>
                    <button class="option-button option-c" onclick="selectAnswer('C')">
                        C
                    </button>
                    <button class="option-button option-d" onclick="selectAnswer('D')">
                        D
                    </button>
                </div>
            </div>

            <div class="player-info">
                <span id="player-name-question">Player</span>
                <div class="player-score" id="player-score-question">0</div>
            </div>
        </div>

        <!-- Results Screen -->
        <div class="screen" id="results-screen">
            <div class="quiz-result-content">
                <h1 class="result-title" id="result-title">Correct</h1>
                <div class="result-icon" id="result-icon">
                    <span id="result-icon-symbol">‚úì</span>
                </div>
                <div class="result-points" id="result-points">+0</div>
            </div>

            <div class="player-info">
                <span id="player-name-results">Player</span>
                <div class="player-score" id="player-score-results">0</div>
            </div>
        </div>

        <!-- Final Results Screen -->
        <div class="screen" id="final-results-screen">
            <div class="final-results-content">
                
                <!-- Player's Final Position and Badge -->
                <div class="player-final-position">
                    <div class="final-rank" id="final-rank">4th</div>
                    <div class="final-badge" id="final-badge">
                        <!-- Badge will be shown only for top 3 -->
                    </div>
                </div>
                
                <!-- Player Name and Score -->
                <div class="final-player-info">
                    <div class="final-player-name" id="final-player-name">Player</div>
                    <div class="final-score" id="final-score">0 points</div>
                </div>
                
                <button class="play-again-btn" onclick="playAgain()">Play Again</button>
            </div>
        </div>
    </div>



    <script>
        let currentGameCode = '';
        let playerName = '';
        let playerId = '';
        let currentScore = 0;
        let questionStartTime = 0;
        let waitingRoomPollingInterval = null;
        let synchronizedCountdownInterval = null;
        let lastSelectedAnswer = null;
        let lastAnswerTimeTaken = 0;
        let resultsPollingInterval = null;
        let nextQuestionPollingInterval = null;
        let answerSubmitted = false;
        // Track question changes to reset state even if previous answer was submitted
        let lastQuestionSeen = -1;

        // Get game code from URL parameters
        function getGameCodeFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('code');
        }

        // Enter game code
        async function enterGameCode() {
            const gameCodeInput = document.getElementById('game-code-input');
            const code = gameCodeInput.value.trim().replace(/\s/g, ''); // Remove spaces
            
            if (code.length < 6) {
                showMessage('Please enter a valid game code', 'error');
                return;
            }

            try {
                // Check if game exists in Supabase
                const session = await GameDB.getGameSession(code);
                if (!session) {
                    showMessage('Game not found. Please check the code.', 'error');
                    return;
                }

                currentGameCode = code;
                showScreen('nickname-screen');
                
                // Initialize real-time subscriptions
                initializeGameSubscriptions(code);
                
                // Initialize next question broadcast listener
                initializeNextQuestionListener(code);
                
                console.log('‚úÖ Real-time subscriptions initialized for game:', code);
                
                // Test if subscriptions are working after a short delay
                setTimeout(() => {
                    console.log('üîç Testing subscription status...');
                    console.log('Quiz state subscription:', window.quizStateSubscription?.state);
                    console.log('Game session subscription:', window.gameSessionSubscription?.state);
                }, 3000);
                
            } catch (error) {
                console.error('Error checking game:', error);
                showMessage('Error connecting to game. Please try again.', 'error');
            }
        }

        // Join the game
        async function joinGame() {
            const nicknameInput = document.getElementById('nickname-input');
            const name = nicknameInput.value.trim();
            
            if (name.length < 2) {
                showMessage('Please enter a valid name (at least 2 characters)', 'error');
                return;
            }

            try {
                playerName = name;
                playerId = generatePlayerId();
                
                // Add player to game in Supabase
                await GameDB.addPlayer(currentGameCode, {
                    id: playerId,
                    name: playerName
                });
                
                showScreen('waiting-room-screen');
                updatePlayerDisplay();
                
                console.log('Player joined! Now listening for game start...');
                // Ensure we're listening for game session updates
                console.log('Current game code:', currentGameCode);
                console.log('Player name:', playerName);
                
                // Log current game session status
                GameDB.getGameSession(currentGameCode).then(session => {
                    console.log('Current game session:', session);
                });
                
                console.log('‚úÖ Player successfully joined game. Waiting for real-time updates...');
                // Start fallback polling
                startWaitingRoomPolling();
                // Start heartbeat to maintain connection
                startHeartbeat();
                
            } catch (error) {
                console.error('Error joining game:', error);
                showMessage('Error joining game. Please try again.', 'error');
            }
        }

        // Generate unique player ID
        function generatePlayerId() {
            return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Leave the room
        async function leaveRoom() {
            try {
                if (playerId) {
                    await GameDB.removePlayer(currentGameCode, playerId);
                }
                cleanupSubscriptions();
                window.location.href = 'player-online.html';
            } catch (error) {
                console.error('Error leaving room:', error);
            }
        }

        // Play again
        function playAgain() {
            cleanupSubscriptions();
            cleanupPollingIntervals();
            window.location.href = 'player-online.html';
        }

        // Show a specific screen
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        // Show message
        function showMessage(message, type = 'info') {
            const container = document.getElementById('message-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = message;
            container.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 3000);
        }

        // Update player display
        function updatePlayerDisplay() {
            const elements = [
                'player-name-display',
                'player-name-loading',
                'player-name-info',
                'player-name-question',
                'player-name-results'
            ];
            
            elements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = playerName;
                }
            });
        }

        // Update score display
        function updateScoreDisplay() {
            const elements = [
                'player-score-loading',
                'player-score-info',
                'player-score-question',
                'player-score-results'
            ];
            
            elements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = currentScore;
                }
            });
        }

        // Select answer
        async function selectAnswer(answer) {
            if (answerSubmitted) return;
            
            if (questionStartTime === 0) {
                questionStartTime = Date.now();
            }
            
            const timeTaken = Math.floor((Date.now() - questionStartTime) / 1000);
            lastSelectedAnswer = answer;
            lastAnswerTimeTaken = timeTaken;
            answerSubmitted = true;
            
            try {
                // Submit answer to Supabase with correct question index
                const questionIndex = lastQuestionSeen >= 0 ? lastQuestionSeen : 0;
                console.log('üéØ Submitting answer for question index:', questionIndex, 'Answer:', answer);
                console.log('üêõ [DEBUG SUBMIT] lastQuestionSeen:', lastQuestionSeen);
                console.log('üêõ [DEBUG SUBMIT] calculated questionIndex:', questionIndex);
                console.log('üêõ [DEBUG SUBMIT] answer:', answer);
                console.log('üêõ [DEBUG SUBMIT] timeTaken:', timeTaken);
                await GameDB.submitAnswer(currentGameCode, playerId, questionIndex, answer, timeTaken);
                
                // Disable all buttons
                document.querySelectorAll('.option-button').forEach(btn => {
                    btn.disabled = true;
                });
                
                // Show waiting screen while others answer
                showScreen('loading-screen');
                const loadingTitle = document.querySelector('#loading-screen .loading-title');
                if (loadingTitle) loadingTitle.textContent = 'Waiting for other players to answer...';
                // DISABLED - results polling now handled by quiz state updates only
                // startResultsPolling();
                
            } catch (error) {
                console.error('Error submitting answer:', error);
                showMessage('Error submitting answer. Please try again.', 'error');
                answerSubmitted = false; // Reset on error to allow retry
            }
        }

        // Simplified transition polling that ONLY checks for phase changes, NO result recalculation
        function startSimplifiedTransitionPolling() {
            if (resultsTransitionPollingInterval) {
                clearInterval(resultsTransitionPollingInterval);
            }
            
            console.log('üîç [SIMPLE TRANSITION] Starting phase transition polling (NO result recalculation)');
            
            resultsTransitionPollingInterval = setInterval(async () => {
                try {
                    const { data } = await window.supabaseClient
                        .from('quiz_states')
                        .select('*')
                        .eq('game_code', currentGameCode)
                        .single();
                    
                    if (data) {
                        console.log('üîç [SIMPLE TRANSITION] Current phase:', data.phase);
                        
                        // ONLY transition to next phases, DO NOT recalculate results
                        if (data.phase === 'scoreboard') {
                            console.log('üîç [SIMPLE TRANSITION] Moving to scoreboard');
                            clearInterval(resultsTransitionPollingInterval);
                            resultsTransitionPollingInterval = null;
                            showScreen('scoreboard-screen');
                            updatePlayerDisplay();
                        } else if (data.phase === 'final-results') {
                            console.log('üîç [SIMPLE TRANSITION] Moving to final results');
                            clearInterval(resultsTransitionPollingInterval);
                            resultsTransitionPollingInterval = null;
                            showScreen('final-screen');
                            updatePlayerDisplay();
                        }
                    }
                } catch (error) {
                    console.error('üîç [SIMPLE TRANSITION] Error:', error);
                }
            }, 2000);
        }

        // DISABLED - Fallback polling: wait for phase 'results' then switch
        function startResultsPolling_DISABLED() {
            if (resultsPollingInterval) return;
            console.log('üîÑ [RESULTS POLLING] Starting results polling for game:', currentGameCode);
            resultsPollingInterval = setInterval(async () => {
                try {
                    console.log('üîÑ [RESULTS POLLING] Checking for results phase...');
                    const { data, error } = await window.supabaseClient
                        .from('quiz_states')
                        .select('*')
                        .eq('game_code', currentGameCode)
                        .single();
                    if (error) {
                        console.error('üîÑ [RESULTS POLLING] Database error:', error);
                        return;
                    }
                    console.log('üîÑ [RESULTS POLLING] Current phase:', data?.phase);
                    if (data && data.phase === 'results') {
                        console.log('üîÑ [RESULTS POLLING] ‚úÖ Results phase detected! Triggering handleQuizStateUpdate...');
                        clearInterval(resultsPollingInterval);
                        resultsPollingInterval = null;
                        // Move to results and compute display
                        handleQuizStateUpdate({
                            detail: {
                                gameCode: currentGameCode,
                                quizState: {
                                    phase: data.phase,
                                    currentQuestion: data.current_question,
                                    questionData: data.question_data
                                }
                            }
                        });
                        const question = data.question_data;
                        try {
                            let isCorrect = false;
                            let pointsGained = 0;
                            
                            console.log('üêõ [DEBUG POLLING] Question data:', JSON.stringify(question));
                            console.log('üêõ [DEBUG POLLING] Last selected answer:', lastSelectedAnswer);
                            
                            if (question && lastSelectedAnswer) {
                                const selectedIndex = ['A','B','C','D'].indexOf(lastSelectedAnswer);
                                console.log('üêõ [DEBUG POLLING] Selected index:', selectedIndex);
                                console.log('üêõ [DEBUG POLLING] Correct answer index:', question.correct);
                                isCorrect = selectedIndex === question.correct;
                                console.log('üêõ [DEBUG POLLING] Is correct?', isCorrect);
                                if (isCorrect) {
                                    const questionTimeLimit = 20; // seconds (player side uses hardcoded for compatibility)
                                    const t = Math.min(lastAnswerTimeTaken, questionTimeLimit);
                                    pointsGained = Math.max(500, Math.min(1000, Math.round((1 - (t / questionTimeLimit)) * 500 + 500)));
                                }
                            }
                            const titleEl = document.getElementById('result-title');
                            const iconEl = document.getElementById('result-icon');
                            const iconSym = document.getElementById('result-icon-symbol');
                            const pointsEl = document.getElementById('result-points');
                            if (titleEl && iconEl && iconSym && pointsEl) {
                                titleEl.textContent = isCorrect ? 'Correct' : 'Wrong';
                                iconEl.className = isCorrect ? 'result-icon correct' : 'result-icon wrong';
                                iconSym.textContent = isCorrect ? '‚úì' : '‚úó';
                                pointsEl.textContent = isCorrect ? `+${pointsGained}` : '+0';
                            }
                            // Refresh score from session
                            const session = await GameDB.getGameSession(currentGameCode);
                            if (session && session.scores && session.scores[playerName] != null) {
                                currentScore = session.scores[playerName];
                            }
                    updateScoreDisplay();
                        } catch {}
                    }
                } catch {}
            }, 1000);
        }

        // Super aggressive polling specifically for scoreboard to next question transition
        let scoreboardToNextPollingInterval = null;
        function startScoreboardToNextQuestionPolling() {
            if (scoreboardToNextPollingInterval) {
                console.log('[SCOREBOARD POLL] Scoreboard to next question polling already active');
                return;
            }
            
            console.log('[SCOREBOARD POLL] üö® Starting SUPER AGGRESSIVE scoreboard to next question polling...');
            scoreboardToNextPollingInterval = setInterval(async () => {
                try {
                    console.log('[SCOREBOARD POLL] üîç Checking for next question transition...');
                    const { data, error } = await window.supabaseClient
                        .from('quiz_states')
                        .select('*')
                        .eq('game_code', currentGameCode)
                        .single();
                    
                    if (error) {
                        console.error('[SCOREBOARD POLL] ‚ùå Database error:', error);
                        return;
                    }
                    
                    console.log('[SCOREBOARD POLL] ‚úÖ Raw DB data received:', data);
                    console.log('[SCOREBOARD POLL] Phase:', data?.phase);
                    console.log('[SCOREBOARD POLL] Current Question:', data?.current_question);
                    console.log('[SCOREBOARD POLL] Countdown:', data?.countdown);
                    
                    if (data && data.phase === 'question-preview') {
                        console.log('[SCOREBOARD POLL] üéØ DETECTED QUESTION-PREVIEW! HOST CLICKED NEXT!');
                        
                        // Clear this aggressive polling
                        clearInterval(scoreboardToNextPollingInterval);
                        scoreboardToNextPollingInterval = null;
                        
                        // Reset player state
                        answerSubmitted = false;
                        lastSelectedAnswer = null;
                        lastAnswerTimeTaken = 0;
                        lastQuestionSeen = data.current_question;
                        
                        // Force transition to countdown screen immediately
                        console.log('[SCOREBOARD POLL] üöÄ FORCING TRANSITION TO COUNTDOWN SCREEN');
                        document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
                        document.getElementById('countdown-screen').classList.add('active');
                        
                        // Reset countdown tracking and start synchronized countdown
                        resetCountdownTracking();
                        let playerPreviewCountdown = data.countdown || data.question_data?.countdown || 10;
                        updateCountdownDisplay(playerPreviewCountdown, 'scoreboard-poll');
                        
                        // Clear any existing countdown interval
                        if (synchronizedCountdownInterval) {
                            clearInterval(synchronizedCountdownInterval);
                            synchronizedCountdownInterval = null;
                        }
                        
                        // Start countdown timer that matches host's countdown
                        console.log('[SCOREBOARD POLL] üîÑ Setting up countdown interval...');
                        synchronizedCountdownInterval = setInterval(() => {
                            playerPreviewCountdown--;
                            console.log('[SCOREBOARD POLL] üïê Player preview countdown:', playerPreviewCountdown);
                            console.log('[SCOREBOARD POLL] üïê Current active screen:', document.querySelector('.screen.active')?.id);
                            
                            if (playerPreviewCountdown > 0) {
                                updateCountdownDisplay(playerPreviewCountdown, 'scoreboard-poll-sync');
                            } else {
                                console.log('[SCOREBOARD POLL] üéØ Player preview countdown finished!');
                                clearInterval(synchronizedCountdownInterval);
                                synchronizedCountdownInterval = null;
                                // Start polling for live question transition
                                startPreviewPolling();
                            }
                        }, 1000);
                        console.log('[SCOREBOARD POLL] üîÑ Countdown interval set up successfully');
                        
                        // Update quiz title
                        const quizTitle = document.querySelector('#countdown-screen .quiz-title');
                        if (quizTitle && data.current_question !== null) {
                            quizTitle.textContent = `Question ${data.current_question + 1}`;
                        }
                        
                        // Update question content if available
                        if (data.question_data) {
                            updateQuestionContent(data.question_data);
                        }
                        
                        // Start preview polling to handle the countdown
                        startPreviewPolling();
                        
                        console.log('[SCOREBOARD POLL] ‚úÖ Successfully transitioned to countdown screen!');
                        return;
                    }
                    
                    // Also check for direct final-results transition
                    if (data && data.phase === 'final-results') {
                        console.log('[SCOREBOARD POLL] üéâ Direct transition to final results detected!');
                        clearInterval(scoreboardToNextPollingInterval);
                        scoreboardToNextPollingInterval = null;
                        
                        resetCountdownTracking();
                        showScreen('final-results-screen');
                        await updateFinalResults();
                        return;
                    }
                    
                } catch (error) {
                    console.error('[SCOREBOARD POLL] ‚ùå Exception:', error);
                }
            }, 50); // Poll every 50ms for ultra-fast response!
        }

        // While on scoreboard/loading screen, poll for next question preview to resync
        function startNextQuestionPolling() {
            if (nextQuestionPollingInterval) {
                console.log('[POLL] Next question polling already active');
                return;
            }
            
                                console.log('[POLL] Starting next question polling...');
            nextQuestionPollingInterval = setInterval(async () => {
                try {
                    console.log('[POLL] üîç Polling quiz_states table for game:', currentGameCode);
                    const { data, error } = await window.supabaseClient
                        .from('quiz_states')
                        .select('*')
                        .eq('game_code', currentGameCode)
                        .single();
                    if (error) {
                        console.error('[POLL] ‚ùå Database error:', error);
                        console.error('[POLL] Error details:', {
                            code: error.code,
                            message: error.message,
                            details: error.details,
                            hint: error.hint
                        });
                        return;
                    }
                    console.log('[POLL] ‚úÖ Raw DB data received:', data);
                    console.log('[POLL] üìä Analysis:');
                    console.log('  - Phase:', data?.phase);
                    console.log('  - Countdown:', data?.countdown);
                    console.log('  - Question Data:', data?.question_data);
                    console.log('  - Current Question:', data?.current_question);
                    console.log('  - Updated At:', data?.updated_at);
                    console.log('  - Current Screen:', document.querySelector('.screen.active')?.id);
                    console.log('  - Answer Submitted:', answerSubmitted);
                    
                    // üö® EMERGENCY FINAL RESULTS CHECK - Always check for final-results in main polling
                    if (data && data.phase === 'final-results') {
                        console.log('[POLL] üö® EMERGENCY: Final results phase detected in main polling!');
                        clearInterval(nextQuestionPollingInterval);
                        nextQuestionPollingInterval = null;
                        showScreen('final-results-screen');
                        await updateFinalResults();
                        return;
                    }
                    
                    // üö® EMERGENCY RESULTS CHECK - Also check for results phase
                    if (data && data.phase === 'results') {
                        console.log('[POLL] üö® EMERGENCY: Results phase detected in main polling!');
                        handleQuizStateUpdate({
                            detail: {
                                gameCode: currentGameCode,
                                quizState: {
                                    phase: data.phase,
                                    currentQuestion: data.current_question,
                                    questionData: data.question_data
                                }
                            }
                        });
                        return;
                    }
                    
                    if (data && data.phase === 'question-preview') {
                        console.log('[POLL] ‚úÖ Detected question-preview phase! Transitioning from results to countdown...');
                        clearInterval(nextQuestionPollingInterval);
                        nextQuestionPollingInterval = null;
                        
                        // Force screen transition
                        console.log('[POLL] Current screen before force transition:', document.querySelector('.screen.active')?.id);
                        document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
                        document.getElementById('countdown-screen').classList.add('active');
                        console.log('[POLL] Screen changed to countdown-screen');
                        
                        answerSubmitted = false;
                        enableOptionButtons();
                        
                        // Start synchronized countdown for player to match host's countdown
                        resetCountdownTracking(); // Reset tracking before starting new countdown
                        let playerPreviewCountdown = data.countdown || data.question_data?.countdown || 10;
                        console.log('[POLL] Starting synchronized countdown:', playerPreviewCountdown);
                        updateCountdownDisplay(playerPreviewCountdown, 'polling');
                        
                        // Clear any existing countdown interval
                        if (synchronizedCountdownInterval) {
                            clearInterval(synchronizedCountdownInterval);
                            synchronizedCountdownInterval = null;
                        }
                        
                        // Start countdown timer that matches host's countdown
                        console.log('[POLL] üîÑ Setting up countdown interval...');
                        synchronizedCountdownInterval = setInterval(() => {
                            playerPreviewCountdown--;
                            console.log('[POLL] üïê Player preview countdown:', playerPreviewCountdown);
                            console.log('[POLL] üïê Current active screen:', document.querySelector('.screen.active')?.id);
                            
                            if (playerPreviewCountdown > 0) {
                                updateCountdownDisplay(playerPreviewCountdown, 'polling-sync');
                            } else {
                                console.log('[POLL] üéØ Player preview countdown finished!');
                                clearInterval(synchronizedCountdownInterval);
                                synchronizedCountdownInterval = null;
                                // Start polling for live question transition
                                startPreviewPolling();
                            }
                        }, 1000);
                        console.log('[POLL] üîÑ Countdown interval set up successfully');
                        
                        // Update quiz title with correct question number
                        const quizTitle = document.querySelector('#countdown-screen .quiz-title');
                        if (quizTitle && data.question_data) {
                            const questionNumber = (data.current_question !== null && data.current_question !== undefined) ? data.current_question + 1 : 1;
                            quizTitle.textContent = `Question ${questionNumber}`;
                        }
                        
                        if (data.question_data) {
                            updateQuestionContent(data.question_data);
                        }
                        
                        // Also trigger the quiz state update handler manually since real-time might be failing
                        console.log('[POLL] Manually triggering quiz state update handler...');
                        try {
                            handleQuizStateUpdate({
                                detail: {
                                    gameCode: currentGameCode,
                                    quizState: {
                                        phase: data.phase,
                                        currentQuestion: data.current_question,
                                        questionData: data.question_data,
                                        countdown: countdown
                                    }
                                }
                            });
                        } catch (e) {
                            console.error('[POLL] Error triggering manual quiz state update:', e);
                        }
                        
                        // Begin preview->live fallback
                        startPreviewPolling();
                    }
                    // Also check for final-results phase to handle quiz end
                    else if (data && data.phase === 'final-results') {
                        console.log('[POLL] ‚úÖ Detected final-results phase! Game ended.');
                        clearInterval(nextQuestionPollingInterval);
                        nextQuestionPollingInterval = null;
                        console.log('[POLL] üöÄ Transitioning to final-results-screen...');
                        showScreen('final-results-screen');
                        console.log('[POLL] üèÜ Calling updateFinalResults...');
                        await updateFinalResults();
                        console.log('[POLL] ‚úÖ Final results transition complete!');
                    }
                    // EMERGENCY CHECK: Always poll for final-results regardless of other conditions
                    else if (data) {
                        console.log('[POLL] üîç Emergency check - Current phase:', data.phase, 'Looking for final-results...');
                        if (data.phase === 'final-results') {
                            console.log('[POLL] üö® EMERGENCY: Final results detected via fallback!');
                            clearInterval(nextQuestionPollingInterval);
                            nextQuestionPollingInterval = null;
                            showScreen('final-results-screen');
                            await updateFinalResults();
                        }
                    }
                } catch (err) {
                    console.error('[POLL] Exception during polling:', err);
                }
            }, 100); // Even faster polling (100ms) for immediate response during transitions
        }

        // NOTE: The robust quiz state handler is defined later in the file.

        // Track the last countdown value to prevent flicker
        let lastCountdownValue = -1;
        let countdownUpdateSource = null;

        // Reset countdown tracking when changing phases
        function resetCountdownTracking() {
            lastCountdownValue = -1;
            countdownUpdateSource = null;
        }

        // Update countdown display
        function updateCountdownDisplay(count, source = 'unknown') {
            console.log('üéØ [DEBUG] updateCountdownDisplay called with:', { count, source, lastCountdownValue, countdownUpdateSource });
            
            // Prevent rapid updates that cause flicker (only if from same source)
            if (count === lastCountdownValue && source === countdownUpdateSource) {
                console.log('üö´ [DEBUG] Skipping update - same value from same source');
                return; // Skip if same value from same source
            }
            
            // Allow countdown resets (starting new countdown from 10) and normal countdown progression
            // Only prevent backwards movement within the same countdown sequence
            const isCountdownReset = count === 10 || count === 9 || count === 8; // Starting new countdown (expanded to catch more resets)
            const isNormalProgression = count <= lastCountdownValue; // Normal countdown 10->9->8...
            const isAllowedUpdate = isCountdownReset || isNormalProgression || lastCountdownValue === -1;
            
            console.log('üéØ [DEBUG] Update validation:', { isCountdownReset, isNormalProgression, isAllowedUpdate });
            
            if (!isAllowedUpdate) {
                console.log('üö´ [DEBUG] Preventing invalid countdown transition:', lastCountdownValue, '->', count, 'from source:', source);
                return;
            }
            
            console.log('üïê [DEBUG] Proceeding with countdown update to:', count, 'from source:', source);
            lastCountdownValue = count;
            countdownUpdateSource = source;
            
            // Update by ID (primary method)
            const countdownById = document.getElementById('countdown-display');
            console.log('üéØ [DEBUG] Found countdown element by ID:', !!countdownById);
            if (countdownById) {
                const oldValue = countdownById.textContent;
                countdownById.textContent = count;
                console.log('üì± [DEBUG] Updated countdown by ID:', oldValue, '->', count);
            } else {
                console.error('‚ùå [DEBUG] countdown-display element not found!');
            }
            
            // Update by class (fallback)
            const countdownElements = document.querySelectorAll('.countdown-number');
            console.log('üéØ [DEBUG] Found countdown elements by class:', countdownElements.length);
            countdownElements.forEach((element, index) => {
                if (element && element !== countdownById) {
                    const oldValue = element.textContent;
                    element.textContent = count;
                    console.log(`üì± [DEBUG] Updated countdown by class [${index}]:`, oldValue, '->', count);
                }
            });
            
            console.log('‚úÖ [DEBUG] Countdown update complete:', count);
        }

        // Update question content (simple player interface)
        function updateQuestionContent(questionData) {
            console.log('üìù Updating question content for player interface:', questionData);
            
            try {
                // For player interface, just hide C and D buttons if it's a True/False question
                const optionButtons = [
                    document.querySelector('.option-a'),
                    document.querySelector('.option-b'),
                    document.querySelector('.option-c'),
                    document.querySelector('.option-d')
                ];
                
                if (questionData.options && questionData.options.length === 2) {
                    // True/False question - hide C and D buttons
                    optionButtons[0].style.display = 'flex'; // A
                    optionButtons[1].style.display = 'flex'; // B
                    optionButtons[2].style.display = 'none'; // C
                    optionButtons[3].style.display = 'none'; // D
                    console.log('‚úÖ True/False question layout applied');
                } else {
                    // Multiple choice question - show all buttons
                    optionButtons.forEach(btn => {
                        if (btn) btn.style.display = 'flex';
                    });
                    console.log('‚úÖ Multiple choice question layout applied');
                }
                
            } catch (error) {
                console.error('‚ùå Error updating question content:', error);
            }
        }

        // Re-enable option buttons for a new question
        function enableOptionButtons() {
            document.querySelectorAll('.option-button').forEach(btn => {
                btn.disabled = false;
            });
        }

        // Synchronized countdown for player
        function showSynchronizedCountdown(startTimeISO) {
            const countdownScreen = document.getElementById('countdown-screen');
            showScreen('countdown-screen');
            let countdown = 10;
            updateCountdownDisplay(countdown, 'synchronized');
            const startTimestamp = new Date(startTimeISO).getTime();
            const now = Date.now();
            let delay = Math.max(0, startTimestamp - now);
            // Update countdown every 250ms
            synchronizedCountdownInterval = setInterval(() => {
                const now2 = Date.now();
                const secondsLeft = Math.ceil((startTimestamp - now2) / 1000);
                updateCountdownDisplay(Math.max(0, secondsLeft), 'synchronized-tick');
                if (secondsLeft <= 0) {
                    clearInterval(synchronizedCountdownInterval);
                    synchronizedCountdownInterval = null;
                    // Start the game UI
                    updatePlayerDisplay();
                    // Hide the waiting room and prepare for quiz
                    const leaveBtn = document.querySelector('.leave-room-btn');
                    if (leaveBtn) leaveBtn.style.display = 'none';
                    // Now waiting for quiz state updates... also start fallback polling
                    console.log('‚úÖ Synchronized countdown complete. Now waiting for quiz state updates...');
                    // Start fallback polling to ensure transition even if realtime misses events
                    try { startPreviewPolling(); } catch (e) { console.warn('Could not start preview polling:', e); }
                }
            }, 250);
        }

        // Modify polling to only transition if status is 'starting' and start_time is present
        function startWaitingRoomPolling() {
            if (waitingRoomPollingInterval) return;
            waitingRoomPollingInterval = setInterval(async () => {
                if (!currentGameCode) return;
                try {
                    const session = await GameDB.getGameSession(currentGameCode);
                    console.log('[Polling] Checked game session status:', session?.status);
                    
                    // Only start countdown if we're actually in waiting room, not during question flow
                    const currentScreen = document.querySelector('.screen.active')?.id;
                    const isInWaitingRoom = currentScreen === 'waiting-room-screen';
                    
                    if (session && session.status === 'starting' && session.start_time && isInWaitingRoom) {
                        console.log('[Polling] Synchronized start detected via polling!');
                        clearInterval(waitingRoomPollingInterval);
                        waitingRoomPollingInterval = null;
                        showSynchronizedCountdown(session.start_time);
                    } else if (session && session.status === 'starting' && session.start_time && !isInWaitingRoom) {
                        console.log('[Polling] üö´ Ignoring polling start countdown - not in waiting room');
                    }
                } catch (err) {
                    console.error('[Polling] Error checking game session status:', err);
                }
            }, 2000);
        }

        // Update handleGameSessionUpdate to use synchronized countdown
        function handleGameSessionUpdate(payload) {
            const { session } = payload.detail;
            console.log('=== GAME SESSION UPDATE RECEIVED ===');
            console.log('Full payload:', payload);
            console.log('Session data:', session);
            console.log('Session status:', session.status);
            console.log('Current screen:', document.querySelector('.screen.active')?.id);
            console.log('=====================================');
            
            // Synchronized start (only for initial game start, not during question previews)
            const currentScreen = document.querySelector('.screen.active')?.id;
            const isInQuestionFlow = currentScreen === 'countdown-screen' || currentScreen === 'question-screen' || currentScreen === 'results-screen';
            
            if (session.status === 'starting' && session.start_time && !isInQuestionFlow) {
                console.log('üéÆ Starting initial game countdown');
                showSynchronizedCountdown(session.start_time);
                // Stop fallback polling
                if (waitingRoomPollingInterval) {
                    clearInterval(waitingRoomPollingInterval);
                    waitingRoomPollingInterval = null;
                }
            } else if (session.status === 'starting' && session.start_time && isInQuestionFlow) {
                console.log('üö´ Ignoring game start countdown - already in question flow');
            }
            
            if (session.scores && session.scores[playerName]) {
                currentScore = session.scores[playerName];
                updateScoreDisplay();
            }
        }

        // Initialize next question broadcast listener
        function initializeNextQuestionListener(gameCode) {
            console.log('üéß Setting up next question broadcast listener for game:', gameCode);
            
            try {
                const nextQuestionChannel = window.supabaseClient.channel(`next_question_${gameCode}`, {
                    config: { broadcast: { self: true } }
                });
                
                nextQuestionChannel
                    .on('broadcast', { event: 'next_question' }, (payload) => {
                        console.log('üîî RECEIVED NEXT QUESTION BROADCAST:', payload);
                        const { game_code, question_index, timestamp } = payload.payload;
                        
                        if (game_code === currentGameCode) {
                            console.log('üöÄ HOST CLICKED NEXT! BROADCAST RECEIVED! Immediately transitioning...');
                            
                            // Clear any existing scoreboard polling since we got the broadcast
                            if (scoreboardToNextPollingInterval) {
                                clearInterval(scoreboardToNextPollingInterval);
                                scoreboardToNextPollingInterval = null;
                                console.log('üõë Cleared scoreboard polling due to broadcast');
                            }
                            
                            // Immediately reset answer state and transition
                            answerSubmitted = false;
                            lastSelectedAnswer = null;
                            lastAnswerTimeTaken = 0;
                            lastQuestionSeen = question_index;
                            
                            // Force transition to loading screen first
                            showScreen('loading-screen');
                            const loadingTitle = document.querySelector('#loading-screen .loading-title');
                            if (loadingTitle) loadingTitle.textContent = 'Moving to next question...';
                            
                            // Start aggressive polling for the question-preview state
                            startNextQuestionPolling();
                            
                            console.log('‚úÖ Player ready for next question transition via broadcast');
                        } else {
                            console.log('‚ùå Broadcast game code mismatch:', game_code, 'vs', currentGameCode);
                        }
                    })
                    .subscribe((status) => {
                        console.log('Next question broadcast listener status:', status);
                    });
                    
                // Store reference for cleanup
                window.nextQuestionChannel = nextQuestionChannel;
                
            } catch (error) {
                console.error('‚ùå Failed to setup next question listener:', error);
            }
        }

        // Initialize event listeners
        function initializeEventListeners() {
            // Only attach game session updates here. The quiz state listener is
            // attached after the robust handler definition at the end of file.
            window.addEventListener('gameSessionUpdated', handleGameSessionUpdate);
            // Start sync via broadcast event if available
            window.addEventListener('gameStartBroadcast', (e) => {
                const startTimeISO = e.detail?.start_time;
                if (startTimeISO) {
                    console.log('[Broadcast] Starting synchronized countdown from broadcast.');
                    showSynchronizedCountdown(startTimeISO);
                }
            });
        }

        // Live Reaction System
        let reactionBurstTimeout = null;
        let reactionCount = 0;
        let reactionCooldown = false;
        let lastReactionTime = 0;
        const REACTION_COOLDOWN_MS = 200; // Minimum 200ms between reactions to prevent spam
        
        async function sendReaction(emoji) {
            if (!currentGameCode || !playerId) {
                console.log('No game code or player ID available for reaction');
                return;
            }
            
            // Throttle reactions to prevent spam and maintain performance
            const now = Date.now();
            if (reactionCooldown || (now - lastReactionTime) < REACTION_COOLDOWN_MS) {
                console.log('Reaction throttled');
                return;
            }
            
            reactionCooldown = true;
            lastReactionTime = now;
            
            // Reset cooldown after minimum interval
            setTimeout(() => {
                reactionCooldown = false;
            }, REACTION_COOLDOWN_MS);
            
            try {
                // Add visual feedback to button
                const buttons = document.querySelectorAll('.reaction-btn');
                buttons.forEach(btn => {
                    const img = btn.querySelector('.reaction-icon');
                    if (img && img.alt.toLowerCase() === emoji) {
                        btn.classList.add('sending');
                        setTimeout(() => btn.classList.remove('sending'), 400);
                        
                        // Add burst effect for multiple quick taps
                        clearTimeout(reactionBurstTimeout);
                        reactionCount++;
                        
                        if (reactionCount > 1) {
                            btn.classList.add('burst');
                            setTimeout(() => btn.classList.remove('burst'), 300);
                        }
                        
                        reactionBurstTimeout = setTimeout(() => {
                            reactionCount = 0;
                        }, 1000);
                    }
                });
                
                // Broadcast reaction to all clients using Supabase real-time
                const channelName = `reactions_${currentGameCode}`;
                const reactionData = {
                    emoji: emoji,
                    playerId: playerId,
                    playerName: playerName,
                    timestamp: Date.now(),
                    burst: reactionCount > 1
                };
                
                console.log('üéâ Sending reaction:', reactionData);
                
                const channel = window.supabaseClient.channel(channelName, {
                    config: { broadcast: { self: false } }
                });
                
                await channel.subscribe();
                
                await channel.send({
                    type: 'broadcast',
                    event: 'reaction',
                    payload: reactionData
                });
                
                // Clean up channel after a short delay
                setTimeout(() => {
                    window.supabaseClient.removeChannel(channel);
                }, 1000);
                
            } catch (error) {
                console.error('Error sending reaction:', error);
            }
        }

        // Initialize the game
        function initializeGame() {
            // Check if game code is in URL
            const urlGameCode = getGameCodeFromURL();
            if (urlGameCode) {
                document.getElementById('game-code-input').value = urlGameCode;
                enterGameCode();
            }
            
            initializeEventListeners();
        }

        // Clean up polling intervals
        function cleanupPollingIntervals() {
            if (nextQuestionPollingInterval) {
                clearInterval(nextQuestionPollingInterval);
                nextQuestionPollingInterval = null;
            }
            if (scoreboardToNextPollingInterval) {
                clearInterval(scoreboardToNextPollingInterval);
                scoreboardToNextPollingInterval = null;
            }
            if (finalResultsPollingInterval) {
                clearInterval(finalResultsPollingInterval);
                finalResultsPollingInterval = null;
            }
            if (resultsTransitionPollingInterval) {
                clearInterval(resultsTransitionPollingInterval);
                resultsTransitionPollingInterval = null;
            }
            if (resultsPollingInterval) {
                clearInterval(resultsPollingInterval);
                resultsPollingInterval = null;
            }
            if (universalResultsPollingInterval) {
                clearInterval(universalResultsPollingInterval);
                universalResultsPollingInterval = null;
            }
            if (previewPollingInterval) {
                clearInterval(previewPollingInterval);
                previewPollingInterval = null;
            }
            if (waitingRoomPollingInterval) {
                clearInterval(waitingRoomPollingInterval);
                waitingRoomPollingInterval = null;
            }
            if (synchronizedCountdownInterval) {
                clearInterval(synchronizedCountdownInterval);
                synchronizedCountdownInterval = null;
            }
        }

        // Player heartbeat system to detect disconnections
        let heartbeatInterval = null;
        
        function startHeartbeat() {
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            
            heartbeatInterval = setInterval(async () => {
                if (playerId && currentGameCode) {
                    try {
                        // Update player's last_seen timestamp
                        await window.supabaseClient
                            .from('players')
                            .update({ 
                                last_seen: new Date().toISOString() 
                            })
                            .eq('game_code', currentGameCode)
                            .eq('player_id', playerId);
                    } catch (error) {
                        console.log('Heartbeat failed:', error);
                    }
                }
            }, 30000); // Update every 30 seconds
        }
        
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }
        
        // Clean up player on disconnect
        async function removePlayerOnDisconnect() {
            if (playerId && currentGameCode) {
                try {
                    await GameDB.removePlayer(currentGameCode, playerId);
                    console.log('Player removed successfully');
                } catch (error) {
                    console.log('Failed to remove player:', error);
                }
            }
            stopHeartbeat();
            cleanupSubscriptions();
            cleanupPollingIntervals();
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', removePlayerOnDisconnect);
        
        // Also listen for other disconnect events
        window.addEventListener('pagehide', removePlayerOnDisconnect);
        window.addEventListener('unload', removePlayerOnDisconnect);
        
        // Listen for visibility change (when tab becomes hidden)
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'hidden') {
                // Player might be closing the tab, remove them after a delay
                setTimeout(() => {
                    if (document.visibilityState === 'hidden') {
                        removePlayerOnDisconnect();
                    }
                }, 5000); // Wait 5 seconds to see if they come back
            }
        });

        // Initialize when page loads
        window.addEventListener('load', initializeGame);

        // Handle Enter key for game code input
        document.getElementById('game-code-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                enterGameCode();
            }
        });

        // Handle Enter key for nickname input
        document.getElementById('nickname-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                joinGame();
            }
        });

        // Global: log every quiz state event
        window.addEventListener('quizStateUpdated', function(payload) {
            console.log('[GLOBAL] quizStateUpdated event:', payload);
            console.log('[GLOBAL] Event detail:', payload.detail);
            console.log('[GLOBAL] Quiz state:', payload.detail.quizState);
        });

        // Fallback: if stuck on preview screen, force transition after 6 seconds
        let previewFallbackTimeout = null;
        
        // Fallback: if player is still on question screen when timer should end, force transition
        let questionTimeoutFallback = null;

        // Fallback: if stuck on preview screen, poll quiz_states every 2s
        let previewPollingInterval = null;

        function startPreviewPolling() {
            if (previewPollingInterval) return;
            console.log('[PREVIEW POLL] Starting preview->live polling...');
            previewPollingInterval = setInterval(async () => {
                try {
                    const { data, error } = await window.supabaseClient
                        .from('quiz_states')
                        .select('*')
                        .eq('game_code', currentGameCode)
                        .single();
                    if (error) {
                        console.error('[PREVIEW POLL] Error polling quiz_states:', error);
                        return;
                    }
                    console.log('[PREVIEW POLL] Polled quiz_states:', data);
                    console.log('[PREVIEW POLL] Current phase:', data?.phase, 'Current screen:', document.querySelector('.screen.active')?.id);
                    
                    if (data && data.phase === 'live-question') {
                        console.log('[PREVIEW POLL] ‚úÖ Detected live-question phase! Transitioning to question screen...');
                        clearInterval(previewPollingInterval);
                        previewPollingInterval = null;
                        
                        // Only transition if answer hasn't been submitted
                        if (!answerSubmitted) {
                            console.log('[PREVIEW POLL] Forcing transition to question-screen...');
                            
                            // Force screen transition
                            document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
                            document.getElementById('question-screen').classList.add('active');
                            
                            updatePlayerDisplay();
                            updateScoreDisplay();
                            questionStartTime = Date.now();
                            enableOptionButtons(); // Re-enable buttons for new question
                            
                            // Update quiz title on question screen
                            const questionTitle = document.querySelector('#question-screen .quiz-title');
                            if (questionTitle && data.current_question !== null && data.current_question !== undefined) {
                                questionTitle.textContent = `Question ${data.current_question + 1}`;
                            }
                            
                            if (data.question_data) {
                                updateQuestionContent(data.question_data);
                            }
                            
                            // Start universal polling for unanswered players
                            startUniversalResultsPolling();
                            
                            console.log('[PREVIEW POLL] ‚úÖ Successfully transitioned to question screen');
                        } else {
                            console.log('[PREVIEW POLL] Answer already submitted, staying on current screen');
                        }
                    }
                } catch (err) {
                    console.error('[PREVIEW POLL] Exception during polling:', err);
                }
            }, 500); // Faster polling (500ms) during preview->live transition
        }

        // In handleQuizStateUpdate, start polling if entering preview
        async function handleQuizStateUpdate(payload) {
            const { quizState } = payload.detail;
            console.log('üéØ === QUIZ STATE UPDATE ===');
            console.log('Phase:', quizState.phase);
            console.log('Countdown:', quizState.countdown);
            console.log('Current Question:', quizState.currentQuestion);
            console.log('Question Data:', quizState.questionData);
            console.log('Current Screen:', document.querySelector('.screen.active')?.id);
            console.log('Answer Submitted:', answerSubmitted);
            console.log('==============================');

            // If host moved to a different question index, always reset local answer state
            if (typeof quizState.currentQuestion === 'number' && quizState.currentQuestion !== lastQuestionSeen) {
                console.log('[STATE] Detected new question index. Resetting answer state. From', lastQuestionSeen, 'to', quizState.currentQuestion);
                lastQuestionSeen = quizState.currentQuestion;
                answerSubmitted = false;
                lastSelectedAnswer = null;
                lastAnswerTimeTaken = 0;
            }
            // Clear any previous fallback
            if (previewFallbackTimeout) {
                clearTimeout(previewFallbackTimeout);
                previewFallbackTimeout = null;
            }
            if (previewPollingInterval) {
                clearInterval(previewPollingInterval);
                previewPollingInterval = null;
            }
            switch (quizState.phase) {
                case 'countdown':
                    // This case is now only for the initial game start countdown
                    console.log('Moving to countdown phase (initial game start)');
                    resetCountdownTracking();
                    showScreen('countdown-screen');
                    updatePlayerDisplay();
                    updateScoreDisplay();
                    answerSubmitted = false; // Reset for new question
                    enableOptionButtons(); // Re-enable buttons for new question
                    
                    // Update countdown number if available
                    if (quizState.countdown !== undefined) {
                        updateCountdownDisplay(quizState.countdown, 'quiz-state-countdown');
                    }
                    
                    // Update quiz title - for initial countdown, show generic title
                    const quizTitle = document.querySelector('#countdown-screen .quiz-title');
                    if (quizTitle) {
                        if (quizState.questionData) {
                            quizTitle.textContent = `Question ${(quizState.currentQuestion || 0) + 1}`;
                        } else {
                            quizTitle.textContent = 'Get Ready!';
                        }
                    }
                    
                    // Clear any polling intervals since we got the update
                    if (nextQuestionPollingInterval) {
                        clearInterval(nextQuestionPollingInterval);
                        nextQuestionPollingInterval = null;
                    }
                    break;
                case 'question-preview':
                    console.log('Moving to question preview phase');
                    console.log('Current screen before transition:', document.querySelector('.screen.active')?.id);
                    resetCountdownTracking();
                    showScreen('countdown-screen'); // Ensure player transitions to preview/countdown screen
                    console.log('Screen after transition:', document.querySelector('.screen.active')?.id);
                    updatePlayerDisplay();
                    updateScoreDisplay();
                    answerSubmitted = false; // Reset for new question
                    enableOptionButtons(); // Re-enable buttons for new question
                    
                    // Update quiz title
                    const previewTitle = document.querySelector('#countdown-screen .quiz-title');
                    if (previewTitle && quizState.questionData) {
                        previewTitle.textContent = `Question ${(quizState.currentQuestion || 0) + 1}`;
                    }
                    
                    // Clear any previous polling intervals
                    if (nextQuestionPollingInterval) {
                        clearInterval(nextQuestionPollingInterval);
                        nextQuestionPollingInterval = null;
                    }
                    
                    // Start synchronized countdown for player to match host's 10-second countdown
                    console.log('üïê Starting synchronized player countdown for question preview');
                    resetCountdownTracking(); // Reset tracking before starting new countdown
                    let playerPreviewCountdown = quizState.countdown || 10;
                    updateCountdownDisplay(playerPreviewCountdown, 'quiz-state-preview');
                    
                    // Clear any existing countdown interval
                    if (synchronizedCountdownInterval) {
                        clearInterval(synchronizedCountdownInterval);
                        synchronizedCountdownInterval = null;
                    }
                    
                    // Start countdown timer that matches host's countdown
                    console.log('üîÑ Setting up countdown interval...');
                    synchronizedCountdownInterval = setInterval(() => {
                        playerPreviewCountdown--;
                        console.log('üïê [QUESTION-PREVIEW] Player preview countdown:', playerPreviewCountdown);
                        console.log('üïê [QUESTION-PREVIEW] Current active screen:', document.querySelector('.screen.active')?.id);
                        
                        if (playerPreviewCountdown > 0) {
                            updateCountdownDisplay(playerPreviewCountdown, 'synchronized-preview');
                                } else {
                            console.log('üéØ [QUESTION-PREVIEW] Player preview countdown finished! Ready for live question...');
                            clearInterval(synchronizedCountdownInterval);
                            synchronizedCountdownInterval = null;
                            
                            // Start polling for live question transition
                            startPreviewPolling();
                        }
                    }, 1000);
                    console.log('üîÑ Countdown interval set up successfully');
                    
                    // For question preview, use simple countdown timer for better predictability
                    // (Precise timing is mainly for initial game start)
                    console.log('üéØ Using simple countdown timer for question preview');
                    
                    // Fallback: force after countdown completes and start polling
                            previewFallbackTimeout = setTimeout(() => {
                                const questionScreen = document.getElementById('question-screen');
                                if (!questionScreen.classList.contains('active')) {
                                    console.warn('[FALLBACK] Forcing transition to question-screen after preview timeout!');
                                    document.querySelectorAll('.screen').forEach(screen => {
                                        screen.classList.remove('active');
                                    });
                                    questionScreen.classList.add('active');
                                    startPreviewPolling();
                                }
                    }, 11000); // 11 seconds to account for potential delays
                    break;
                case 'live-question':
                    console.log('üéØ Moving to live question phase');
                    console.log('üéØ Current screen:', document.querySelector('.screen.active')?.id);
                    console.log('üéØ Answer submitted:', answerSubmitted);
                    
                    // Only transition to question screen if answer hasn't been submitted
                    if (!answerSubmitted) {
                        console.log('üéØ Transitioning to question screen...');
                        
                        // Force immediate screen transition
                        document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
                        document.getElementById('question-screen').classList.add('active');
                        console.log('üéØ Screen forcefully changed to question-screen');
                        
                        // Robust: double-check transition after a short delay
                        setTimeout(() => {
                            const questionScreen = document.getElementById('question-screen');
                            if (!questionScreen.classList.contains('active')) {
                                console.warn('üö® [FORCE] Question screen not active, forcing again!');
                                document.querySelectorAll('.screen').forEach(screen => {
                                    screen.classList.remove('active');
                                });
                                questionScreen.classList.add('active');
                            } else {
                                console.log('‚úÖ [DEBUG] Question screen is properly active.');
                            }
                        }, 100);
                        
                        updatePlayerDisplay();
                        updateScoreDisplay();
                        questionStartTime = Date.now();
                        lastSelectedAnswer = null;
                        lastAnswerTimeTaken = 0;
                        enableOptionButtons(); // Re-enable buttons for new question
                        
                        // Update quiz title on question screen
                        const questionTitle = document.querySelector('#question-screen .quiz-title');
                        if (questionTitle && typeof quizState.currentQuestion === 'number') {
                            questionTitle.textContent = `Question ${quizState.currentQuestion + 1}`;
                            console.log('üéØ Quiz title updated to:', `Question ${quizState.currentQuestion + 1}`);
                        }
                        
                        // Update question content if available
                        if (quizState.questionData) {
                            updateQuestionContent(quizState.questionData);
                            console.log('üéØ Question content updated');
                        }
                        
                        // Start universal polling for results phase (for unanswered players)
                        startUniversalResultsPolling();
                        
                        console.log('üéØ ‚úÖ Live question transition complete!');
                    } else {
                        // If answerSubmitted is true but this is a new question index, clear it and transition
                        if (typeof quizState.currentQuestion === 'number' && quizState.currentQuestion !== lastQuestionSeen) {
                            console.warn('üéØ Detected new question while answerSubmitted=true. Resetting and transitioning.');
                            answerSubmitted = false;
                            lastSelectedAnswer = null;
                            lastAnswerTimeTaken = 0;
                            document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
                            document.getElementById('question-screen').classList.add('active');
                            
                            // Update quiz title on question screen
                            const questionTitle = document.querySelector('#question-screen .quiz-title');
                            if (questionTitle) {
                                questionTitle.textContent = `Question ${quizState.currentQuestion + 1}`;
                                console.log('üéØ Quiz title updated to:', `Question ${quizState.currentQuestion + 1}`);
                            }
                            
                            // Start universal polling for results phase
                            startUniversalResultsPolling();
                        } else {
                            console.log('üéØ Player has already submitted answer, staying on current screen');
                        }
                    }
                    
                    // Stop polling if we get here
                    if (previewPollingInterval) {
                        clearInterval(previewPollingInterval);
                        previewPollingInterval = null;
                        console.log('üéØ Stopped preview polling');
                    }
                    break;
                    
                case 'results':
                    console.log('üéØ [QUIZ STATE] Moving to results phase!');
                    console.log('üéØ [QUIZ STATE] Current screen during results:', document.querySelector('.screen.active')?.id);
                    console.log('üéØ [QUIZ STATE] Quiz state data:', JSON.stringify(quizState));
                    console.log('üéØ [QUIZ STATE] Game code:', currentGameCode);
                    console.log('üéØ [QUIZ STATE] Player:', playerName);
                    
                    // CLEAR ALL POLLING INTERVALS TO PREVENT CONFLICTS
                    if (universalResultsPollingInterval) {
                        clearInterval(universalResultsPollingInterval);
                        universalResultsPollingInterval = null;
                        console.log('üõë Cleared universal results polling');
                    }
                    if (resultsPollingInterval) {
                        clearInterval(resultsPollingInterval);
                        resultsPollingInterval = null;
                        console.log('üõë Cleared results polling');
                    }
                    if (resultsTransitionPollingInterval) {
                        clearInterval(resultsTransitionPollingInterval);
                        resultsTransitionPollingInterval = null;
                        console.log('üõë Cleared results transition polling');
                    }
                    if (finalResultsPollingInterval) {
                        clearInterval(finalResultsPollingInterval);
                        finalResultsPollingInterval = null;
                        console.log('üõë Cleared final results polling');
                    }
                    
                    resetCountdownTracking();
                    showScreen('results-screen');
                    updatePlayerDisplay();
                    
                    // SINGLE AUTHORITATIVE RESULT CALCULATION - NO OVERRIDES ALLOWED
                    try {
                        const question = quizState.questionData;
                        let isCorrect = false;
                        let pointsGained = 0;
                        
                        console.log('üéØ [FINAL RESULT] Question data:', JSON.stringify(question));
                        console.log('üéØ [FINAL RESULT] Last selected answer:', lastSelectedAnswer);
                        console.log('üéØ [FINAL RESULT] Current question index:', quizState.currentQuestion);
                        console.log('üéØ [FINAL RESULT] Last question seen:', lastQuestionSeen);
                        
                        if (question && lastSelectedAnswer) {
                            // Player submitted an answer
                            const selectedIndex = ['A','B','C','D'].indexOf(lastSelectedAnswer);
                            console.log('üéØ [FINAL RESULT] Selected index:', selectedIndex);
                            console.log('üéØ [FINAL RESULT] Correct answer index:', question.correct);
                            isCorrect = selectedIndex === question.correct;
                            console.log('üéØ [FINAL RESULT] Is correct?', isCorrect);
                            if (isCorrect) {
                                const questionTimeLimit = 20;
                                const t = Math.min(lastAnswerTimeTaken, questionTimeLimit);
                                pointsGained = Math.max(500, Math.min(1000, Math.round((1 - (t / questionTimeLimit)) * 500 + 500)));
                            }
                        } else {
                            console.log('üéØ [FINAL RESULT] Player did not answer - marking as wrong');
                            isCorrect = false;
                            pointsGained = 0;
                        }
                        
                        // SET RESULT DISPLAY ONCE AND NEVER OVERRIDE
                        const titleEl = document.getElementById('result-title');
                        const iconEl = document.getElementById('result-icon');
                        const iconSym = document.getElementById('result-icon-symbol');
                        const pointsEl = document.getElementById('result-points');
                        
                        if (titleEl && iconEl && iconSym && pointsEl) {
                            titleEl.textContent = isCorrect ? 'Correct' : 'Wrong';
                            iconEl.className = isCorrect ? 'result-icon correct' : 'result-icon wrong';
                            iconSym.textContent = isCorrect ? '‚úì' : '‚úó';
                            pointsEl.textContent = isCorrect ? `+${pointsGained}` : '+0';
                            
                            console.log('üéØ [FINAL RESULT] Display set to:', titleEl.textContent);
                            console.log('üéØ [FINAL RESULT] No more result recalculations will happen');
                        }
                        
                        // Update score from session
                        GameDB.getGameSession(currentGameCode).then(session => {
                            if (session && session.scores && session.scores[playerName] != null) {
                                currentScore = session.scores[playerName];
                    updateScoreDisplay();
                            }
                        });
                        
                    } catch (e) { 
                        console.error('Result display error:', e); 
                    }
                    
                    updateScoreDisplay();
                    
                    // Start simplified transition polling ONLY for next phase detection
                    console.log('üîç [RESULTS] Starting simplified transition polling...');
                    startSimplifiedTransitionPolling();
                    
                    break;
                    
                case 'scoreboard':
                    console.log('Moving to scoreboard phase');
                    console.log('Current screen during scoreboard:', document.querySelector('.screen.active')?.id);
                    resetCountdownTracking();
                    
                    // Stop results transition polling since we've reached scoreboard
                    if (resultsTransitionPollingInterval) {
                        clearInterval(resultsTransitionPollingInterval);
                        resultsTransitionPollingInterval = null;
                        console.log('üõë Stopped results transition polling');
                    }
                    
                    // Check if this is the last question - if so, prepare for final results
                    const totalQuestions = 5; // Updated for Gametize History & Fun Facts Quiz
                    const currentQuestionNum = (quizState.currentQuestion || 0) + 1;
                    console.log('üìä [SCOREBOARD] Question progress:', currentQuestionNum, '/', totalQuestions);
                    console.log('üìä [SCOREBOARD] Current question index:', quizState.currentQuestion);
                    console.log('üìä [SCOREBOARD] Calculated question number:', currentQuestionNum);
                    
                    if (currentQuestionNum >= totalQuestions) {
                        console.log('üèÅ [SCOREBOARD] Last question completed! Starting final results polling...');
                        // Show loading screen but prepare for final results
                        showScreen('loading-screen');
                        const loadingTitle = document.querySelector('#loading-screen .loading-title');
                        if (loadingTitle) loadingTitle.textContent = 'Calculating final results...';
                        
                        // DISABLED - final results polling replaced by simplified version
                        // startFinalResultsPolling();
                    } else {
                        console.log('‚û°Ô∏è More questions remaining, waiting for host to click Next...');
                        // Show loading screen and IMMEDIATELY start aggressive polling for next question
                        showScreen('loading-screen');
                        const loadingTitle = document.querySelector('#loading-screen .loading-title');
                        if (loadingTitle) loadingTitle.textContent = 'Waiting for host...';
                        
                        // Start SUPER AGGRESSIVE polling for next question (faster than normal)
                        startScoreboardToNextQuestionPolling();
                    }
                    
                    updatePlayerDisplay();
                    updateScoreDisplay();
                    
                    // Also check immediately in case the question-preview phase is already active
                    // Check multiple times with short intervals to catch rapid state changes
                    const immediateChecks = [10, 50, 100, 200, 500, 1000, 2000]; // More frequent checks
                    immediateChecks.forEach(delay => {
                        setTimeout(async () => {
                            try {
                                console.log(`[IMMEDIATE CHECK ${delay}ms] Checking for question-preview phase...`);
                                const { data, error } = await window.supabaseClient
                                    .from('quiz_states')
                                    .select('*')
                                    .eq('game_code', currentGameCode)
                                    .single();
                                console.log(`[IMMEDIATE CHECK ${delay}ms] Raw data:`, data);
                                if (!error && data && data.phase === 'question-preview') {
                                    console.log(`[IMMEDIATE CHECK ${delay}ms] Found question-preview! Transitioning...`);
                                    
                                    // Clear polling since we found the state change
                                    if (nextQuestionPollingInterval) {
                                        clearInterval(nextQuestionPollingInterval);
                                        nextQuestionPollingInterval = null;
                                    }
                                    
                                    // Force screen transition
                                    console.log(`[IMMEDIATE CHECK ${delay}ms] Current screen before force transition:`, document.querySelector('.screen.active')?.id);
                                    document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
                                    document.getElementById('countdown-screen').classList.add('active');
                                    console.log(`[IMMEDIATE CHECK ${delay}ms] Screen changed to countdown-screen`);
                                    
                                    answerSubmitted = false;
                                    enableOptionButtons();
                                    
                                    // Start synchronized countdown for player to match host's countdown
                                    resetCountdownTracking(); // Reset tracking before starting new countdown
                                    let playerPreviewCountdown = data.countdown || data.question_data?.countdown || 10;
                                    console.log(`[IMMEDIATE CHECK ${delay}ms] Starting synchronized countdown:`, playerPreviewCountdown);
                                    updateCountdownDisplay(playerPreviewCountdown, 'immediate-check');
                                    
                                    // Clear any existing countdown interval
                                    if (synchronizedCountdownInterval) {
                                        clearInterval(synchronizedCountdownInterval);
                                        synchronizedCountdownInterval = null;
                                    }
                                    
                                    // Start countdown timer that matches host's countdown
                                    console.log(`[IMMEDIATE CHECK ${delay}ms] üîÑ Setting up countdown interval...`);
                                    synchronizedCountdownInterval = setInterval(() => {
                                        playerPreviewCountdown--;
                                        console.log(`[IMMEDIATE CHECK] üïê Player preview countdown:`, playerPreviewCountdown);
                                        console.log(`[IMMEDIATE CHECK] üïê Current active screen:`, document.querySelector('.screen.active')?.id);
                                        
                                        if (playerPreviewCountdown > 0) {
                                            updateCountdownDisplay(playerPreviewCountdown, 'immediate-check-sync');
                                        } else {
                                            console.log(`[IMMEDIATE CHECK] üéØ Player preview countdown finished!`);
                                            clearInterval(synchronizedCountdownInterval);
                                            synchronizedCountdownInterval = null;
                                            // Start polling for live question transition
                                            startPreviewPolling();
                                        }
                                    }, 1000);
                                    console.log(`[IMMEDIATE CHECK ${delay}ms] üîÑ Countdown interval set up successfully`);
                                    
                                    const quizTitle = document.querySelector('#countdown-screen .quiz-title');
                                    if (quizTitle && data.question_data) {
                                        const questionNumber = (data.current_question !== null && data.current_question !== undefined) ? data.current_question + 1 : 1;
                                        quizTitle.textContent = `Question ${questionNumber}`;
                                    }
                                    if (data.question_data) {
                                        updateQuestionContent(data.question_data);
                                    }
                                    startPreviewPolling();
                                }
                            } catch (e) {
                                console.error(`[IMMEDIATE CHECK ${delay}ms] Error:`, e);
                            }
                        }, delay);
                    });
                    break;
                    
                case 'final-results':
                    console.log('Moving to final results phase');
                    resetCountdownTracking();
                    
                    // Stop all polling intervals since we've reached final results
                    if (resultsTransitionPollingInterval) {
                        clearInterval(resultsTransitionPollingInterval);
                        resultsTransitionPollingInterval = null;
                    }
                    if (finalResultsPollingInterval) {
                        clearInterval(finalResultsPollingInterval);
                        finalResultsPollingInterval = null;
                    }
                    if (nextQuestionPollingInterval) {
                        clearInterval(nextQuestionPollingInterval);
                        nextQuestionPollingInterval = null;
                    }
                    
                    showScreen('final-results-screen');
                    await updateFinalResults();
                    break;
            }
        }

        // Start polling for transition from results screen (either to scoreboard or final-results)
        let resultsTransitionPollingInterval = null;
        function startResultsTransitionPolling() {
            if (resultsTransitionPollingInterval) {
                console.log('[RESULTS TRANSITION] Polling already active');
                return;
            }
            
            console.log('[RESULTS TRANSITION] üîÑ Starting transition polling from results screen...');
            resultsTransitionPollingInterval = setInterval(async () => {
                try {
                    console.log('[RESULTS TRANSITION] üîç Checking for phase changes for game:', currentGameCode);
                    const { data, error } = await window.supabaseClient
                        .from('quiz_states')
                        .select('*')
                        .eq('game_code', currentGameCode)
                        .single();
                    
                    if (error) {
                        console.error('[RESULTS TRANSITION] ‚ùå Database error:', error);
                        console.error('[RESULTS TRANSITION] ‚ùå Error details:', JSON.stringify(error));
                        return;
                    }
                    
                    console.log('[RESULTS TRANSITION] üìä RAW DATABASE DATA:', JSON.stringify(data));
                    console.log('[RESULTS TRANSITION] üìä Current phase:', data?.phase);
                    console.log('[RESULTS TRANSITION] üìä Current question:', data?.current_question);
                    console.log('[RESULTS TRANSITION] üìä Updated at:', data?.updated_at);
                    console.log('[RESULTS TRANSITION] üìä Current screen on player:', document.querySelector('.screen.active')?.id);
                    
                    if (data && data.phase === 'scoreboard') {
                        console.log('[RESULTS TRANSITION] ‚û°Ô∏è Detected scoreboard phase');
                        clearInterval(resultsTransitionPollingInterval);
                        resultsTransitionPollingInterval = null;
                        
                        // Trigger the scoreboard handler manually
                        handleQuizStateUpdate({
                            detail: {
                                gameCode: currentGameCode,
                                quizState: {
                                    phase: data.phase,
                                    currentQuestion: data.current_question,
                                    questionData: data.question_data
                                }
                            }
                        });
                    } else if (data && data.phase === 'final-results') {
                        console.log('[RESULTS TRANSITION] üéâ Detected final-results phase directly!');
                        console.log('[RESULTS TRANSITION] üîÑ Current screen before transition:', document.querySelector('.screen.active')?.id);
                        clearInterval(resultsTransitionPollingInterval);
                        resultsTransitionPollingInterval = null;
                        
                        resetCountdownTracking();
                        console.log('[RESULTS TRANSITION] üöÄ Transitioning to final-results-screen...');
                        showScreen('final-results-screen');
                        console.log('[RESULTS TRANSITION] üîÑ Current screen after transition:', document.querySelector('.screen.active')?.id);
                        console.log('[RESULTS TRANSITION] üéØ Calling updateFinalResults...');
                        await updateFinalResults();
                        console.log('[RESULTS TRANSITION] ‚úÖ Final results update complete!');
                    }
                } catch (err) {
                    console.error('[RESULTS TRANSITION] Exception:', err);
                }
            }, 200); // Fast polling for immediate response
        }

        // Universal polling for results phase - ensures all players (including unanswered) transition to results
        let universalResultsPollingInterval = null;
        function startUniversalResultsPolling() {
            if (universalResultsPollingInterval) {
                console.log('[UNIVERSAL POLL] Universal results polling already active, clearing and restarting...');
                clearInterval(universalResultsPollingInterval);
                universalResultsPollingInterval = null;
            }
            
            console.log('[UNIVERSAL POLL] üîÑ Starting universal results polling for all players...');
            universalResultsPollingInterval = setInterval(async () => {
                try {
                    console.log('[UNIVERSAL POLL] üîç Checking for results phase...');
                    const { data, error } = await window.supabaseClient
                        .from('quiz_states')
                        .select('*')
                        .eq('game_code', currentGameCode)
                        .single();
                    
                    if (error) {
                        console.error('[UNIVERSAL POLL] ‚ùå Database error:', error);
                        return;
                    }
                    
                    console.log('[UNIVERSAL POLL] üìä Current phase:', data?.phase);
                    console.log('[UNIVERSAL POLL] üìä Current screen:', document.querySelector('.screen.active')?.id);
                    console.log('[UNIVERSAL POLL] üìä Answer submitted:', answerSubmitted);
                    
                    if (data && data.phase === 'results') {
                        console.log('[UNIVERSAL POLL] üéâ Results phase detected! Forcing transition for all players...');
                        clearInterval(universalResultsPollingInterval);
                        universalResultsPollingInterval = null;
                        
                        // FORCE immediate screen transition to results - don't rely on handleQuizStateUpdate
                        console.log('[UNIVERSAL POLL] Current screen before force transition:', document.querySelector('.screen.active')?.id);
                        document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
                        document.getElementById('results-screen').classList.add('active');
                        console.log('[UNIVERSAL POLL] Screen forcefully changed to results-screen');
                        
                        // Update player display
                        updatePlayerDisplay();
                        
                        // Compute and display result for unanswered players
                        try {
                            const question = data.question_data;
                            let isCorrect = false;
                            let pointsGained = 0;
                            
                            console.log('üêõ [DEBUG UNIVERSAL] Question data:', JSON.stringify(question));
                            console.log('üêõ [DEBUG UNIVERSAL] Last selected answer:', lastSelectedAnswer);
                            
                            if (question && lastSelectedAnswer) {
                                // Player submitted an answer
                                const selectedIndex = ['A','B','C','D'].indexOf(lastSelectedAnswer);
                                console.log('üêõ [DEBUG UNIVERSAL] Selected index:', selectedIndex);
                                console.log('üêõ [DEBUG UNIVERSAL] Correct answer index:', question.correct);
                                isCorrect = selectedIndex === question.correct;
                                console.log('üêõ [DEBUG UNIVERSAL] Is correct?', isCorrect);
                                if (isCorrect) {
                                    const questionTimeLimit = 20;
                                    const t = Math.min(lastAnswerTimeTaken, questionTimeLimit);
                                    pointsGained = Math.max(500, Math.min(1000, Math.round((1 - (t / questionTimeLimit)) * 500 + 500)));
                                }
                            } else {
                                // Player didn't answer - mark as wrong
                                console.log('[UNIVERSAL POLL] ‚è∞ Player did not answer - marking as wrong');
                                isCorrect = false;
                                pointsGained = 0;
                            }
                            
                            // Update results display
                            const titleEl = document.getElementById('result-title');
                            const iconEl = document.getElementById('result-icon');
                            const iconSym = document.getElementById('result-icon-symbol');
                            const pointsEl = document.getElementById('result-points');
                            
                            if (titleEl && iconEl && iconSym && pointsEl) {
                                titleEl.textContent = isCorrect ? 'Correct' : 'Wrong';
                                iconEl.className = isCorrect ? 'result-icon correct' : 'result-icon wrong';
                                iconSym.textContent = isCorrect ? '‚úì' : '‚úó';
                                pointsEl.textContent = isCorrect ? `+${pointsGained}` : '+0';
                            }
                            
                            console.log('[UNIVERSAL POLL] ‚úÖ Results display updated for player');
                        } catch (e) {
                            console.warn('[UNIVERSAL POLL] Error updating results display:', e);
                        }
                        
                        // Update score from session
                        try {
                            const session = await GameDB.getGameSession(currentGameCode);
                            if (session && session.scores && session.scores[playerName] != null) {
                                currentScore = session.scores[playerName];
                                updateScoreDisplay();
                            }
                        } catch (e) {
                            console.warn('[UNIVERSAL POLL] Error updating score:', e);
                        }
                        
                        // DISABLED - results transition polling replaced by simplified version
                        // startResultsTransitionPolling();
                        
                        console.log('[UNIVERSAL POLL] ‚úÖ Universal results transition complete!');
                    }
                } catch (err) {
                    console.error('[UNIVERSAL POLL] Exception:', err);
                }
            }, 500); // Poll every 500ms for immediate response
        }

        // Start polling specifically for final results phase
        let finalResultsPollingInterval = null;
        function startFinalResultsPolling() {
            if (finalResultsPollingInterval) {
                console.log('[FINAL POLL] Final results polling already active, clearing and restarting...');
                clearInterval(finalResultsPollingInterval);
                finalResultsPollingInterval = null;
            }
            
            console.log('[FINAL POLL] üèÅ Starting final results polling for game:', currentGameCode);
            console.log('[FINAL POLL] Current screen:', document.querySelector('.screen.active')?.id);
            finalResultsPollingInterval = setInterval(async () => {
                try {
                    console.log('[FINAL POLL] üîç Checking for final-results phase...');
                    const { data, error } = await window.supabaseClient
                        .from('quiz_states')
                        .select('*')
                        .eq('game_code', currentGameCode)
                        .single();
                    
                    if (error) {
                        console.error('[FINAL POLL] ‚ùå Database error:', error);
                        return;
                    }
                    
                    console.log('[FINAL POLL] üìä Current phase:', data?.phase);
                    console.log('[FINAL POLL] üìä Current question:', data?.current_question);
                    console.log('[FINAL POLL] üìä Current screen:', document.querySelector('.screen.active')?.id);
                    
                    if (data && data.phase === 'final-results') {
                        console.log('[FINAL POLL] üéâ Final results phase detected! Transitioning...');
                        clearInterval(finalResultsPollingInterval);
                        finalResultsPollingInterval = null;
                        
                        resetCountdownTracking();
                        console.log('[FINAL POLL] üöÄ Showing final-results-screen...');
                        showScreen('final-results-screen');
                        console.log('[FINAL POLL] üèÜ Calling updateFinalResults...');
                        await updateFinalResults();
                        console.log('[FINAL POLL] ‚úÖ Final results transition complete!');
                    }
                } catch (err) {
                    console.error('[FINAL POLL] Exception:', err);
                }
            }, 200); // Very fast polling for final results (200ms)
        }

        // Update final results screen with player ranking and badges
        async function updateFinalResults() {
            try {
                console.log('üèÜ [FINAL UPDATE] Starting final results update for player:', playerName);
                console.log('üèÜ [FINAL UPDATE] Current game code:', currentGameCode);
                
                // Verify final results screen is visible
                const finalScreen = document.getElementById('final-results-screen');
                const isActive = finalScreen?.classList.contains('active');
                console.log('üèÜ [FINAL UPDATE] Final results screen exists:', !!finalScreen);
                console.log('üèÜ [FINAL UPDATE] Final results screen is active:', isActive);
                
                // Get session data and all players to calculate ranking
                const [session, playerRows] = await Promise.all([
                    GameDB.getGameSession(currentGameCode),
                    fetchPlayersFromTable(currentGameCode)
                ]);
                
                console.log('üìä Final session data:', session);
                console.log('üë• All players:', playerRows);
                
                // Get current player's score
                const playerScore = session?.scores?.[playerName] || 0;
                console.log('üéØ Player score:', playerScore);
                
                // Calculate all player rankings
                let allPlayers = [];
                if (session && session.scores && playerRows && playerRows.length > 0) {
                    allPlayers = playerRows.map(player => ({
                        name: player.name,
                        score: session.scores[player.name] || 0
                    })).sort((a, b) => b.score - a.score);
                }
                
                console.log('üìà All players ranked:', allPlayers);
                
                // Find current player's position
                const playerPosition = allPlayers.findIndex(p => p.name === playerName) + 1;
                console.log('üèÖ Player position:', playerPosition);
                
                // Update player name and score
                document.getElementById('final-player-name').textContent = playerName;
                document.getElementById('final-score').textContent = `${playerScore} points`;
                
                // Update ranking display
                const rankElement = document.getElementById('final-rank');
                const badgeElement = document.getElementById('final-badge');
                
                // Show ranking with proper suffix
                const getRankSuffix = (pos) => {
                    if (pos === 1) return '1st';
                    if (pos === 2) return '2nd';
                    if (pos === 3) return '3rd';
                    return `${pos}th`;
                };
                
                rankElement.textContent = getRankSuffix(playerPosition);
                
                // Show badge for top 3 players
                badgeElement.innerHTML = '';
                if (playerPosition === 1) {
                    badgeElement.innerHTML = '<img src="assets/medal_1.png" alt="Gold Medal" class="final-medal">';
                    rankElement.style.color = '#FFD700'; // Gold
                } else if (playerPosition === 2) {
                    badgeElement.innerHTML = '<img src="assets/medal_2.png" alt="Silver Medal" class="final-medal">';
                    rankElement.style.color = '#C0C0C0'; // Silver
                } else if (playerPosition === 3) {
                    badgeElement.innerHTML = '<img src="assets/medal_3.png" alt="Bronze Medal" class="final-medal">';
                    rankElement.style.color = '#CD7F32'; // Bronze
                } else {
                    rankElement.style.color = '#666'; // Default gray for other positions
                }
                
                console.log('‚úÖ Final results updated successfully');
                
            } catch (error) {
                console.error('‚ùå Error updating final results:', error);
                // Fallback display
                document.getElementById('final-player-name').textContent = playerName;
                document.getElementById('final-score').textContent = `${currentScore} points`;
                document.getElementById('final-rank').textContent = '-';
            }
        }

        // Helper function to fetch players from table (copied from host)
        async function fetchPlayersFromTable(gameCode) {
            try {
                const { data, error } = await window.supabaseClient
                    .from('players')
                    .select('*')
                    .eq('game_code', gameCode);

                if (error) {
                    console.error('Error fetching players:', error);
                    return [];
                }
                return data;
            } catch (error) {
                console.error('Error in fetchPlayersFromTable:', error);
                return [];
            }
        }

        window.addEventListener('quizStateUpdated', handleQuizStateUpdate);

        // Mobile keyboard viewport fix
        function handleMobileKeyboard() {
            const initialViewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
            
            function setViewportHeight() {
                const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                document.documentElement.style.setProperty('--vh', `${vh * 0.01}px`);
                
                // Add class when keyboard is likely visible
                if (vh < initialViewportHeight * 0.8) {
                    document.body.classList.add('keyboard-visible');
                } else {
                    document.body.classList.remove('keyboard-visible');
                }
            }
            
            // Set initial height
            setViewportHeight();
            
            // Update on resize
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', setViewportHeight);
            } else {
                window.addEventListener('resize', setViewportHeight);
            }
            
            // For iOS Safari, also listen to orientationchange
            window.addEventListener('orientationchange', () => {
                setTimeout(setViewportHeight, 100);
            });
        }
        
        // Initialize mobile keyboard fix
        if (window.innerWidth <= 768) {
            handleMobileKeyboard();
        }
    </script>
</body>
</html> 