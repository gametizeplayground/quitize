<!DOCTYPE html>
<!--
GAMETIZE HISTORY & FUN FACTS QUIZ - HOST INTERFACE
================================================

To modify the quiz:
1. Update the quiz title in the head section (around line 62)
2. Edit the 'quizQuestions' array (around line 260)
3. Add/remove questions with title, image, options, correct answer index, and explanation
4. Update QUIZ_CONFIG settings for timing and scoring (around line 304)
5. Add corresponding images to assets/questions image/ folder (1.webp, 2.webp, etc.)

Player interface will automatically show simple A/B/C/D buttons.
Host interface displays full question content and images.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quitize - Host Dashboard</title>
    <link rel="stylesheet" href="hoststyles.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4CAF50">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config.js"></script>
</head>
<body>
    <div class="header">
        <img src="assets/logo.png" alt="Quitize Logo" class="logo">
    </div>

    <div class="main-container">
        <!-- Game Code Card moved to top center -->
        <div class="game-code-card">
            <div class="code-section">
                <div class="game-key-label">GAME CODE</div>
                <div class="game-code" id="display-game-code">255 8657</div>
            </div>
            <div class="qr-section">
                <div class="qr-code">
                    <img id="qr-code-image" src="" alt="QR Code" />
                </div>
            </div>
        </div>

        <!-- Players section in the middle -->
        <div class="players-section">
            <div class="players-grid" id="players-grid">
                <!-- Players will be added here dynamically -->
            </div>
            <div class="no-players" id="no-players" style="display: block;">
                No players joined yet
            </div>
        </div>

        <!-- Start button moved to bottom -->
        <div class="game-controls">
            <button class="refresh-button" id="refresh-btn" onclick="refreshQuestions()" title="Refresh Questions">
                <span class="refresh-icon">üîÑ</span>
                Refresh
            </button>
        <button class="start-button" id="start-btn" onclick="startGame()" disabled>
            Start Game
        </button>
        </div>
    </div>

    <!-- Live Reactions Display Area -->
    <div class="reactions-display" id="reactions-display">
        <!-- Floating reactions will appear here -->
    </div>

    <!-- Player count moved to bottom right -->
    <div class="player-count-bottom" id="player-count-container">
        <span id="player-count">0</span> players
    </div>

    <!-- Music and Fullscreen Controls -->
    <div class="controls-bottom" id="controls-container">
        <div class="control-pill">
            <img src="assets/music_off.png" alt="Music Off" id="music-icon" class="control-icon" title="Toggle Music (M)">
            <img src="assets/fullscreen.png" alt="Fullscreen" class="control-icon fullscreen-icon" title="Toggle Fullscreen (F)">
        </div>
    </div>

    <!-- Quiz Countdown Screen -->
    <div class="quiz-screen" id="quiz-countdown-screen">
        <div class="quiz-header">
            <div class="quiz-title">GAMETIZE HISTORY & FUN FACTS</div>
        </div>
        <div class="countdown-circle">
                <span id="quiz-countdown">10</span>
        </div>
    </div>

    <!-- Question Preview Screen -->
    <div class="quiz-screen" id="question-preview-screen">
        <div class="quiz-header">
            <div class="quiz-title">What colour is watermelon?</div>
            <div class="question-counter">1/10</div>
        </div>
        <div class="question-image-container">
            <img src="https://images.unsplash.com/photo-1587822863-4d0a812c7b8f?w=400&h=300&fit=crop" alt="Watermelon" class="question-image">
        </div>
        <div class="timer-bar-container">
            <div class="timer-bar" id="preview-timer-bar"></div>
        </div>
    </div>

    <!-- Live Quiz Question Screen -->
    <div class="quiz-screen" id="live-question-screen">
        <div class="quiz-header">
            <div class="quiz-title" id="live-question-text">What colour is watermelon?</div>
            <div class="question-counter" id="live-question-counter">1/10</div>
        </div>
        <div class="question-content">
            <div class="timer-section">
                <div class="timer-circle">
                    <span id="question-timer">20</span>
                </div>
            </div>
            <div class="question-main">
                <div class="question-image-container">
                    <img src="https://images.unsplash.com/photo-1587822863-4d0a812c7b8f?w=400&h=300&fit=crop" alt="Watermelon" class="question-image" id="live-question-image">
                </div>
                <div class="answer-options">
                    <div class="option-row">
                        <div class="answer-option option-a">
                            <span class="option-letter">A</span>
                            <span class="option-text">Yellow</span>
                        </div>
                        <div class="answer-option option-b">
                            <span class="option-letter">B</span>
                            <span class="option-text">Red</span>
                        </div>
                    </div>
                    <div class="option-row">
                        <div class="answer-option option-c">
                            <span class="option-letter">C</span>
                            <span class="option-text">White</span>
                        </div>
                        <div class="answer-option option-d">
                            <span class="option-letter">D</span>
                            <span class="option-text">Green</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Quiz Results Screen -->
    <div class="quiz-screen" id="quiz-results-screen">
        <div class="results-header">
            <h1 class="quiz-title">Quiz 1</h1>
        </div>
        
        <div class="results-content">
            <div class="results-answers">
                <div class="answer-bar">
                    <div class="answer-bar-chart" id="answer-a-bar" style="height: 0%">
                        <div class="answer-count" id="answer-a-count">0</div>
                    </div>
                    <div class="answer-label">A</div>
                </div>
                <div class="answer-bar">
                    <div class="answer-bar-chart" id="answer-b-bar" style="height: 0%">
                        <div class="answer-count" id="answer-b-count">0</div>
                    </div>
                    <div class="answer-label">B</div>
                </div>
                <div class="answer-bar">
                    <div class="answer-bar-chart" id="answer-c-bar" style="height: 0%">
                        <div class="answer-count" id="answer-c-count">0</div>
                    </div>
                    <div class="answer-label">C</div>
                </div>
                <div class="answer-bar">
                    <div class="answer-bar-chart" id="answer-d-bar" style="height: 0%">
                        <div class="answer-count" id="answer-d-count">0</div>
                    </div>
                    <div class="answer-label">D</div>
                </div>
            </div>
            
            <div class="answer-results">
                <div class="result-option-row">
                    <div class="result-option result-option-a" id="result-option-a">
                        <div class="result-letter">A</div>
                        <div class="result-option-text" id="result-option-text-a">Yellow</div>
                    </div>
                    <div class="result-option result-option-b" id="result-option-b">
                        <div class="result-letter">B</div>
                        <div class="result-option-text" id="result-option-text-b">Red</div>
                    </div>
                </div>
                <div class="result-option-row">
                    <div class="result-option result-option-c" id="result-option-c">
                        <div class="result-letter">C</div>
                        <div class="result-option-text" id="result-option-text-c">White</div>
                    </div>
                    <div class="result-option result-option-d" id="result-option-d">
                        <div class="result-letter">D</div>
                        <div class="result-option-text" id="result-option-text-d">Green</div>
                    </div>
                </div>
            </div>
        </div>
        
        <button class="next-button" onclick="showScoreboard()">Next</button>
    </div>

    <!-- Scoreboard Screen -->
    <div class="quiz-screen" id="scoreboard-screen">
        <div class="scoreboard-header">
            <div class="scoreboard-title">Scoreboard</div>
        </div>
        <div class="scoreboard-content">
            <div class="player-scores" id="player-scores">
                <!-- Player scores will be populated dynamically -->
            </div>
        </div>
        <button class="next-button" onclick="proceedToNextQuestion()">Next</button>
    </div>

    <!-- Final Leaderboard Screen -->
    <div class="quiz-screen" id="final-leaderboard-screen">
        <div class="final-header">
            <img src="assets/logo.png" alt="Quitize Logo" class="logo">
            <button class="play-again-button" onclick="playAgain()">Play Again</button>
        </div>

        <div class="podium-container">
            <!-- 2nd Place -->
            <div class="podium-player second-place">
                <div class="medal-container">
                    <img src="assets/medal_2.png" alt="Silver Medal" class="medal-image">
                </div>
                <div class="podium-info">
                    <div class="podium-rank">2</div>
                    <div class="podium-name">-</div>
                    <div class="podium-score">0</div>
                </div>
            </div>

            <!-- 1st Place (Winner) -->
            <div class="podium-player first-place">
                <div class="medal-container">
                    <img src="assets/medal_1.png" alt="Gold Medal" class="medal-image">
                </div>
                <div class="podium-info">
                    <div class="podium-rank winner-rank">1</div>
                    <div class="podium-name">-</div>
                    <div class="podium-score">0</div>
                </div>
            </div>

            <!-- 3rd Place -->
            <div class="podium-player third-place">
                <div class="medal-container">
                    <img src="assets/medal_3.png" alt="Bronze Medal" class="medal-image">
                </div>
                <div class="podium-info">
                    <div class="podium-rank">3</div>
                    <div class="podium-name">-</div>
                    <div class="podium-score">0</div>
                </div>
            </div>
        </div>
    </div>

    <!-- API Error Screen -->
    <div class="quiz-screen" id="api-error-screen" style="display: none;">
        <!-- This screen will be populated by showApiError -->
    </div>

    <style>
        /* API Error Screen Styles */
        #api-error-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
        }
        
        .error-content {
            max-width: 500px;
            padding: 40px;
        }
        
        .error-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }
        
        .error-content h2 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #ffeb3b;
        }
        
        .error-content p {
            font-size: 18px;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .error-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            margin: 20px 0;
            word-break: break-word;
        }
        
        .retry-button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .retry-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        .retry-icon {
            font-size: 20px;
            animation: spin 2s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Loading Screen Styles */
        #api-loading-screen {
            display: flex !important;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            z-index: 9999 !important;
        }
        
        #api-loading-screen.hidden {
            display: none !important;
        }
        
        .loading-content {
            max-width: 400px;
            padding: 40px;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        .loading-content h2 {
            font-size: 28px;
            margin-bottom: 15px;
            color: #ffeb3b;
        }
        
        .loading-content p {
            font-size: 16px;
            opacity: 0.8;
        }
        
        /* Game Controls Layout */
        .game-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }
        
        .refresh-button {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .refresh-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .refresh-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .refresh-icon {
            font-size: 18px;
        }
        
        .refresh-icon.spinning {
            animation: spin 1s linear infinite;
        }
        
        /* Dynamic option layout adjustments */
        .answer-option[style*="display: none"] {
            opacity: 0;
            pointer-events: none;
        }
        
        .answer-option[style*="display: flex"] {
            opacity: 1;
            pointer-events: auto;
        }
    </style>

    <script>
        let players = [];
        let gameCode = '';
        let currentGameCode = '';
        let gameStarted = false;
        let currentQuestionIndex = 0;
        let questionTimer;
        let isMusicOn = false;
        let backgroundMusic;
        
        // Sound effects
        let gameStartSound;
        let lastCountdownSound;
        let timesUpSound;
        let crowdsSound;

        // ============================================================
        // GAMETIZE API INTEGRATION
        // ============================================================
        // To modify the quiz:
        // 1. Update the topic ID in GAMETIZE_CONFIG below
        // 2. Questions are now fetched automatically from the API
        // 3. Images are provided by the API via challengeImage field
        // 4. Correct answers are determined by matching optionTitle in challengeDescription
        // ============================================================
        
        // Use external Gametize configuration with fallback
        let GAMETIZE_CONFIG;
        
        // Function to initialize configuration
        function initializeGametizeConfig() {
            console.log('üîß Initializing Gametize configuration...');
            
            // Using inline configuration to avoid external script loading issues
            // TODO: Once external config loading is working, this can be updated to use gametize-config.js
            GAMETIZE_CONFIG = {
                baseUrl: 'https://beta.gametize.com/api3',
                topicId: '83890', // Change this for different topics
                limit: 10,
                retryAttempts: 3,
                retryDelay: 2000
            };
            
            console.log('‚úÖ Using inline Gametize configuration:', GAMETIZE_CONFIG);
            
            // Verify configuration is properly set
            if (!GAMETIZE_CONFIG || !GAMETIZE_CONFIG.baseUrl || !GAMETIZE_CONFIG.topicId) {
                console.error('‚ùå Invalid Gametize configuration:', GAMETIZE_CONFIG);
                throw new Error('Invalid Gametize configuration');
            }
            
            console.log('‚úÖ Gametize configuration initialized successfully');
        }
        
        // Global quiz questions from API
        let quizQuestions = [];
        let isApiLoading = false;
        let apiError = null;
        
        // Fetch questions from Gametize API
        async function fetchQuizQuestions() {
            if (isApiLoading) return;
            
            // Ensure configuration is initialized
            if (!GAMETIZE_CONFIG) {
                initializeGametizeConfig();
            }
            
            isApiLoading = true;
            apiError = null;
            
            // Show loading state
            showLoadingState();
            
            try {
                console.log('üì° Fetching questions from Gametize API...');
                console.log('üì° API URL:', `${GAMETIZE_CONFIG.baseUrl}/topics/${GAMETIZE_CONFIG.topicId}/challenges.json?limit=${GAMETIZE_CONFIG.limit}`);
                
                const response = await fetch(`${GAMETIZE_CONFIG.baseUrl}/topics/${GAMETIZE_CONFIG.topicId}/challenges.json?limit=${GAMETIZE_CONFIG.limit}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üì° Raw API response:', data);
                
                if (!data.data || !Array.isArray(data.data)) {
                    throw new Error('Invalid API response format - missing or invalid data array');
                }
                
                if (data.data.length === 0) {
                    throw new Error('No challenges found for this topic');
                }
                
                // Transform API data to quiz format
                quizQuestions = data.data
                    .filter(challenge => {
                        const isValid = challenge.challengeType === 'quiz' && 
                                      challenge.options && 
                                      challenge.options.length > 0;
                        if (!isValid) {
                            console.log('‚ö†Ô∏è Skipping invalid challenge:', challenge);
                        }
                        return isValid;
                    })
                    .map((challenge, index) => {
                        console.log(`üîÑ Processing challenge ${index + 1}:`, challenge.challengeTitle);
                        
                        // Determine correct answer by checking if challengeDescription contains optionTitle
                        let correctAnswerIndex = -1;
                        const options = challenge.options.map((option, optionIndex) => {
                            // Check if this option is the correct answer
                            if (challenge.challengeDescription && 
                                challenge.challengeDescription.toLowerCase().includes(option.optionTitle.toLowerCase())) {
                                correctAnswerIndex = optionIndex;
                                console.log(`‚úÖ Found correct answer: "${option.optionTitle}" at index ${optionIndex}`);
                            }
                            return option.optionTitle;
                        });
                        
                        // If no correct answer found, default to first option
                        if (correctAnswerIndex === -1) {
                            correctAnswerIndex = 0;
                            console.warn(`‚ö†Ô∏è No correct answer found for question: "${challenge.challengeTitle}". Defaulting to first option.`);
                        }
                        
                        const transformedQuestion = {
                            title: challenge.challengeTitle,
                            image: challenge.challengeImage || 'assets/questions image/1.webp', // Use API image or fallback
                            options: options,
                            correct: correctAnswerIndex,
                            explanation: challenge.challengeDescription,
                            challengeId: challenge.id,
                            points: challenge.points || 10
                        };
                        
                        console.log(`‚úÖ Transformed question ${index + 1}:`, transformedQuestion);
                        return transformedQuestion;
                    });
                
                if (quizQuestions.length === 0) {
                    throw new Error('No valid quiz questions found after filtering');
                }
                
                console.log(`‚úÖ Successfully fetched and transformed ${quizQuestions.length} questions from API`);
                
                // Update quiz title to reflect the topic
                updateQuizTitle();
                
                // Hide loading state and any error messages
                hideLoadingState();
                hideApiError();
                
                // Force show main content as backup
                setTimeout(() => {
                    forceShowMainContent();
                }, 200);
                
                // Safety timeout: if loading screen is still visible after 5 seconds, force hide it
                setTimeout(() => {
                    const loadingScreen = document.getElementById('api-loading-screen');
                    if (loadingScreen && loadingScreen.style.display !== 'none') {
                        console.warn('‚ö†Ô∏è Loading screen still visible after 5 seconds, forcing hide...');
                        forceShowMainContent();
                    }
                }, 5000);
                
            } catch (error) {
                console.error('‚ùå Failed to fetch questions from API:', error);
                apiError = error;
                hideLoadingState();
                showApiError(error);
            } finally {
                isApiLoading = false;
            }
        }
        
        // Show API error with retry button
        function showApiError(error) {
            // Hide main container and show error screen
            document.querySelector('.main-container').style.display = 'none';
            document.querySelector('.header').style.display = 'none';
            
            // Create or update error screen
            let errorScreen = document.getElementById('api-error-screen');
            if (!errorScreen) {
                errorScreen = document.createElement('div');
                errorScreen.id = 'api-error-screen';
                errorScreen.className = 'quiz-screen active';
                errorScreen.innerHTML = `
                    <div class="error-content">
                        <div class="error-icon">‚ö†Ô∏è</div>
                        <h2>Failed to Load Questions</h2>
                        <p>Unable to fetch questions from the server.</p>
                        <p class="error-details">${error.message}</p>
                        <button class="retry-button" onclick="retryApiCall()">
                            <span class="retry-icon">üîÑ</span>
                            Try Again
                        </button>
                    </div>
                `;
                document.body.appendChild(errorScreen);
            } else {
                errorScreen.classList.add('active');
                errorScreen.querySelector('.error-details').textContent = error.message;
            }
        }
        
        // Show loading state while fetching questions
        function showLoadingState() {
            console.log('üîß Showing loading state...');
            
            // Hide main container and show loading screen
            const mainContainer = document.querySelector('.main-container');
            const header = document.querySelector('.header');
            
            if (mainContainer) {
                mainContainer.style.display = 'none';
                console.log('üîß Main container hidden');
            }
            
            if (header) {
                header.style.display = 'none';
                console.log('üîß Header hidden');
            }
            
            // Create or update loading screen
            let loadingScreen = document.getElementById('api-loading-screen');
            if (!loadingScreen) {
                console.log('üîß Creating new loading screen...');
                loadingScreen = document.createElement('div');
                loadingScreen.id = 'api-loading-screen';
                loadingScreen.className = 'quiz-screen active';
                loadingScreen.innerHTML = `
                    <div class="loading-content">
                        <div class="loading-spinner"></div>
                        <h2>Loading Questions...</h2>
                        <p>Fetching quiz questions from Gametize</p>
                        <button class="skip-loading-btn" onclick="forceShowMainContent()" style="margin-top: 20px; padding: 10px 20px; background: #ffeb3b; color: #333; border: none; border-radius: 25px; cursor: pointer;">
                            Skip Loading
                        </button>
                    </div>
                `;
                document.body.appendChild(loadingScreen);
                console.log('‚úÖ Loading screen created and added to DOM');
            } else {
                console.log('üîß Using existing loading screen, adding active class');
                loadingScreen.classList.add('active');
            }
            
            console.log('‚úÖ Loading state shown successfully');
        }
        
        // Hide loading state
        function hideLoadingState() {
            console.log('üîß Hiding loading state...');
            const loadingScreen = document.getElementById('api-loading-screen');
            if (loadingScreen) {
                console.log('üîß Found loading screen, hiding it...');
                loadingScreen.classList.remove('active');
                loadingScreen.classList.add('hidden');
                // Also set inline style as backup
                loadingScreen.style.display = 'none';
                
                // Remove from DOM after a short delay to ensure smooth transition
                setTimeout(() => {
                    if (loadingScreen.parentNode) {
                        loadingScreen.parentNode.removeChild(loadingScreen);
                        console.log('‚úÖ Loading screen removed from DOM');
                    }
                }, 100);
            } else {
                console.log('‚ö†Ô∏è No loading screen found to hide');
            }
            
            // Show main container and header when loading is complete
            const mainContainer = document.querySelector('.main-container');
            const header = document.querySelector('.header');
            
            if (mainContainer) {
                mainContainer.style.display = 'flex';
                console.log('‚úÖ Main container shown');
            }
            
            if (header) {
                header.style.display = 'flex';
                console.log('‚úÖ Header shown');
            }
            
            console.log('‚úÖ Loading state hidden successfully');
        }
        
        // Hide API error and show main content
        function hideApiError() {
            const errorScreen = document.getElementById('api-error-screen');
            if (errorScreen) {
                errorScreen.classList.remove('active');
            }
            
            // Show main container and header
            document.querySelector('.main-container').style.display = 'flex';
            document.querySelector('.header').style.display = 'flex';
        }
        
        // Retry API call
        async function retryApiCall() {
            console.log('üîÑ Retrying API call...');
            await fetchQuizQuestions();
        }
        
        // Update quiz title based on API data
        function updateQuizTitle() {
            if (quizQuestions.length > 0) {
                // Extract topic name from first question or use default
                const firstQuestion = quizQuestions[0];
                const topicName = firstQuestion.title.includes('Gametize') ? 'GAMETIZE QUIZ' : 'QUIZ';
                
                // Update all quiz title elements
                const quizTitleElements = document.querySelectorAll('.quiz-title');
                quizTitleElements.forEach(element => {
                    if (element.textContent.includes('GAMETIZE HISTORY & FUN FACTS')) {
                        element.textContent = topicName;
                    }
                });
            }
        }
        
        // Validate quiz questions before starting game
        function validateQuizQuestions() {
            if (!quizQuestions || quizQuestions.length === 0) {
                alert('No questions available. Please check the API connection.');
                return false;
            }
            
            // Validate each question has required fields
            for (let i = 0; i < quizQuestions.length; i++) {
                const question = quizQuestions[i];
                if (!question.title || !question.options || question.options.length === 0) {
                    console.error(`Invalid question at index ${i}:`, question);
                    alert(`Question ${i + 1} is invalid. Please check the API data.`);
                    return false;
                }
            }
            
            return true;
        }
        
        // Force show main content (fallback function)
        function forceShowMainContent() {
            console.log('üîß Force showing main content...');
            
            // Debug: Check what elements exist
            console.log('üîç DOM elements check:');
            console.log('üîç Loading screen:', document.getElementById('api-loading-screen'));
            console.log('üîç Error screen:', document.getElementById('api-error-screen'));
            console.log('üîç Main container:', document.querySelector('.main-container'));
            console.log('üîç Header:', document.querySelector('.header'));
            
            // Hide any loading or error screens
            const loadingScreen = document.getElementById('api-loading-screen');
            const errorScreen = document.getElementById('api-error-screen');
            
            if (loadingScreen) {
                console.log('üîß Hiding loading screen...');
                loadingScreen.style.display = 'none';
                loadingScreen.classList.remove('active');
                loadingScreen.classList.add('hidden');
                // Remove from DOM
                if (loadingScreen.parentNode) {
                    loadingScreen.parentNode.removeChild(loadingScreen);
                    console.log('‚úÖ Loading screen removed from DOM');
                }
            }
            
            if (errorScreen) {
                console.log('üîß Hiding error screen...');
                errorScreen.style.display = 'none';
                errorScreen.classList.remove('active');
            }
            
            // Show main container and header
            const mainContainer = document.querySelector('.main-container');
            const header = document.querySelector('.header');
            
            if (mainContainer) {
                mainContainer.style.display = 'flex';
                console.log('‚úÖ Main container force shown');
            } else {
                console.warn('‚ö†Ô∏è Main container not found');
            }
            
            if (header) {
                header.style.display = 'flex';
                console.log('‚úÖ Header force shown');
            } else {
                console.warn('‚ö†Ô∏è Header not found');
            }
            
            console.log('‚úÖ Main content force shown successfully');
        }
        
        // Configuration settings for easy customization
        const QUIZ_CONFIG = {
            questionTimeLimit: 20, // seconds per question
            previewCountdown: 10,  // seconds for question preview
            resultsDisplayTime: 5, // seconds to show results
            pointsConfig: {
                maxPoints: 1000,
                minPoints: 500,
                timeBonus: true // award bonus points for faster answers
            }
        };

        // Generate random game code
        async function generateGameCode() {
            let attempts = 0;
            const maxAttempts = 10;
            
            // Keep generating until we find a unique code
            do {
                gameCode = Math.floor(100000 + Math.random() * 900000).toString();
                attempts++;
                
                if (attempts > maxAttempts) {
                    alert('Unable to generate a unique game code. Please try again.');
                    return;
                }
                
                // Check if this code already exists
                try {
                    const exists = await GameDB.gameCodeExists(gameCode);
                    if (!exists) break; // Found a unique code
                    console.log(`Game code ${gameCode} already exists, generating new one...`);
                } catch (error) {
                    console.warn('Error checking game code existence:', error);
                    break; // Continue with this code if check fails
                }
            } while (attempts <= maxAttempts);
            
            // Format with space for display
            const formattedCode = gameCode.slice(0, 3) + ' ' + gameCode.slice(3);
            document.getElementById('display-game-code').textContent = formattedCode;
            
            // Initialize game session in Supabase
            currentGameCode = gameCode;
            try {
                await GameDB.createGameSession(gameCode);
                // Initialize real-time subscriptions
                initializeGameSubscriptions(gameCode);
                console.log('Game session created successfully with code:', gameCode);
            } catch (error) {
                console.error('Failed to create game session:', error);
                alert('Failed to create game session. Please try again.');
                return;
            }
            
            // Generate QR code for the game
            generateQRCode();
            
            return gameCode;
        }

        // Generate QR Code for the game
        function generateQRCode() {
            // Construct the game URL with the current domain and game code
            const baseURL = window.location.origin;
            const gameURL = `${baseURL}/player-online.html?code=${currentGameCode}`;
            
            // Use QR Server API to generate the QR code
            const qrCodeURL = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(gameURL)}`;
            
            const qrCodeImage = document.getElementById('qr-code-image');
            qrCodeImage.src = qrCodeURL;
            qrCodeImage.style.width = '100%';
            qrCodeImage.style.height = '100%';
            qrCodeImage.style.objectFit = 'contain';
            qrCodeImage.style.borderRadius = '8px';
            
            // Add click handler to copy URL
            qrCodeImage.onclick = function() {
                copyToClipboard(gameURL);
                showMessage('Game URL copied to clipboard!');
            };
            
            // Add error handling
            qrCodeImage.onerror = function() {
                console.error('Failed to load QR code');
                qrCodeImage.style.backgroundColor = '#f0f0f0';
                qrCodeImage.style.display = 'flex';
                qrCodeImage.style.alignItems = 'center';
                qrCodeImage.style.justifyContent = 'center';
                qrCodeImage.style.fontSize = '12px';
                qrCodeImage.style.color = '#666';
                qrCodeImage.alt = 'QR Code unavailable';
            };
            
            // Domain information for reference
            const domain = window.location.hostname === 'localhost' ? 'quitize.game' : window.location.hostname;
            
            console.log('QR Code generated for URL:', gameURL);
        }

        // Copy text to clipboard
        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).catch(err => {
                    console.error('Failed to copy: ', err);
                    fallbackCopyTextToClipboard(text);
                });
            } else {
                fallbackCopyTextToClipboard(text);
            }
        }

        // Fallback copy method for older browsers
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
            }
            document.body.removeChild(textArea);
        }

        // Show temporary message
        function showMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = message;
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '20px';
            messageDiv.style.right = '20px';
            messageDiv.style.background = '#4fc3a3';
            messageDiv.style.color = 'white';
            messageDiv.style.padding = '10px 20px';
            messageDiv.style.borderRadius = '25px';
            messageDiv.style.zIndex = '1000';
            messageDiv.style.fontSize = '14px';
            messageDiv.style.fontWeight = '500';
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 3000);
        }

        // Add this function to fetch players from the players table
        async function fetchPlayersFromTable(gameCode) {
            const { data, error } = await window.supabaseClient
                .from('players')
                .select('*')
                .eq('game_code', gameCode);

            if (error) {
                console.error('Error fetching players:', error);
                return [];
            }
            return data;
        }

        // Cleanup inactive players (those who haven't been seen for more than 60 seconds)
        async function cleanupInactivePlayers() {
            try {
                const oneMinuteAgo = new Date(Date.now() - 60000).toISOString();
                
                // Find inactive players
                const { data: inactivePlayers, error } = await window.supabaseClient
                    .from('players')
                    .select('*')
                    .eq('game_code', currentGameCode)
                    .lt('last_seen', oneMinuteAgo);
                
                if (error) {
                    console.error('Error finding inactive players:', error);
                    return;
                }
                
                // Remove inactive players
                if (inactivePlayers && inactivePlayers.length > 0) {
                    console.log(`Removing ${inactivePlayers.length} inactive players:`, inactivePlayers.map(p => p.name));
                    
                    for (const player of inactivePlayers) {
                        await GameDB.removePlayer(currentGameCode, player.player_id);
                    }
                }
            } catch (error) {
                console.error('Error cleaning up inactive players:', error);
            }
        }

        // Update player list from Supabase
        async function updatePlayerListFromSession() {
            try {
                console.log('Fetching players for game code:', currentGameCode);
                
                // First, cleanup inactive players
                await cleanupInactivePlayers();
                
                const playerRows = await fetchPlayersFromTable(currentGameCode);
                console.log('Fetched player rows:', playerRows);
                const newPlayers = playerRows.map(p => p.name);
                // Only update if there are actual changes
                if (JSON.stringify(players) !== JSON.stringify(newPlayers)) {
                    players = newPlayers;
                    // Update the player count and list
                    const playerCount = players.length;
                    document.getElementById('player-count').textContent = playerCount;
                    // Update the players display
                    updatePlayersDisplay();
                    updateStartButton();
                }
            } catch (error) {
                console.error('Error updating player list:', error);
            }
        }

        // Listen for player changes
        function startPlayerListener() {
            // Listen for custom events from Supabase subscriptions
            window.addEventListener('gameSessionUpdated', function(e) {
                if (e.detail.gameCode === currentGameCode) {
                    updatePlayerListFromSession();
                }
            });

            window.addEventListener('playerJoined', function(e) {
                console.log('Player joined:', e.detail.player);
                updatePlayerListFromSession();
            });

            window.addEventListener('playerLeft', function(e) {
                console.log('Player left:', e.detail.player);
                updatePlayerListFromSession();
            });
        }

        // Update the players display
        function updatePlayersDisplay() {
            const playersGrid = document.getElementById('players-grid');
            const noPlayersMsg = document.getElementById('no-players');
            
            playersGrid.innerHTML = '';
            
            if (players.length === 0) {
                noPlayersMsg.style.display = 'block';
            } else {
                noPlayersMsg.style.display = 'none';
                players.forEach(player => {
                    const playerBadge = document.createElement('div');
                    playerBadge.className = 'player-badge';
                    playerBadge.textContent = player;
                    playersGrid.appendChild(playerBadge);
                });
            }
        }

        // Update player count
        function updatePlayerCount() {
            document.getElementById('player-count').textContent = players.length;
        }

        // Refresh questions from API
        async function refreshQuestions() {
            console.log('üîÑ Manually refreshing questions...');
            await fetchQuizQuestions();
        }

        // Update start button state
        function updateStartButton() {
            const startBtn = document.getElementById('start-btn');
            const refreshBtn = document.getElementById('refresh-btn');
            
            if (players.length > 0 && !gameStarted && quizQuestions.length > 0) {
                startBtn.disabled = false;
                startBtn.textContent = 'Start Game';
            } else {
                startBtn.disabled = true;
                startBtn.textContent = players.length === 0 ? 'Start Game' : 'Loading...';
            }
            
            // Update refresh button state
            if (refreshBtn) {
                refreshBtn.disabled = isApiLoading;
                refreshBtn.innerHTML = isApiLoading ? 
                    '<span class="refresh-icon spinning">üîÑ</span> Loading...' : 
                    '<span class="refresh-icon">üîÑ</span> Refresh';
            }
        }

        // Start the game
        async function startGame() {
            try {
                // Validate quiz questions before starting
                if (!validateQuizQuestions()) {
                    return;
                }
                
                // Fetch players from the players table
                const playerRows = await fetchPlayersFromTable(currentGameCode);
                const totalPlayers = playerRows.length;

                if (totalPlayers === 0) {
                    alert('No players have joined yet!');
                    return;
                }

                gameStarted = true;

                // Stop background music and play game start sound
                if (backgroundMusic && isMusicOn) {
                    backgroundMusic.pause();
                }
                if (gameStartSound) {
                    gameStartSound.currentTime = 0; // Reset to beginning
                    gameStartSound.play().catch(e => console.log('Game start sound blocked:', e));
                }

                // Synchronized start: set status to 'starting' and set start_time 5 seconds in the future
                const startTime = Date.now() + 10000; // 10 seconds from now
                let retries = 3;
                let lastError = null;
                let startTimeISO = new Date(startTime).toISOString();
                while (retries > 0) {
                    try {
                        console.log('üì° Sending game start update to database (synchronized start)...');
                        const result = await GameDB.updateGameSession(currentGameCode, {
                            status: 'starting',
                            start_time: startTimeISO
                        });
                        console.log('‚úÖ Game session updated successfully:', result);
                        break; // Success, exit retry loop
                    } catch (error) {
                        retries--;
                        lastError = error;
                        console.error(`‚ùå Failed to update game session, retries left: ${retries}`, error);
                        console.error('Error details:', {
                            message: error.message,
                            code: error.code,
                            details: error.details,
                            hint: error.hint
                        });
                        if (retries === 0) {
                            // Disable start button and show error
                            const startBtn = document.getElementById('start-btn');
                            if (startBtn) {
                                startBtn.disabled = true;
                                startBtn.textContent = 'Error!';
                            }
                            alert('Failed to start game due to a database error. Please refresh and try again.');
                            throw error; // Re-throw if no retries left
                        }
                        await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
                    }
                }

                updateStartButton();

                // Immediately start the synchronized countdown for the host
                showSynchronizedCountdown(startTimeISO);
                // Also broadcast start immediately to connected players to reduce delay
                if (window.sendStartBroadcast) {
                    window.sendStartBroadcast(currentGameCode, startTimeISO);
                }
                
            } catch (error) {
                console.error('Error starting game:', error);
                gameStarted = false;
                updateStartButton();
                // Error alert already shown above
            }
        }

        // Register the gameSessionUpdated event listener at the top-level so it is always active
        window.addEventListener('gameSessionUpdated', onHostGameSessionUpdated);

        function onHostGameSessionUpdated(e) {
            const session = e.detail.session;
            if (session.status === 'starting' && session.start_time) {
                showSynchronizedCountdown(session.start_time);
            }
        }

        // Synchronized countdown function (ensure only one countdown runs)
        let hostSynchronizedCountdownInterval = null;
        function showSynchronizedCountdown(startTimeISO) {
            // Hide main container, header, player count, and controls ONLY when countdown actually begins
            document.querySelector('.main-container').style.display = 'none';
            document.querySelector('.header').style.display = 'none';
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            const countdownScreen = document.getElementById('quiz-countdown-screen');
            countdownScreen.classList.add('active');
            let countdown = QUIZ_CONFIG.previewCountdown; // configurable countdown time
            const countdownElement = document.getElementById('quiz-countdown');
            countdownElement.textContent = countdown;
            const startTimestamp = new Date(startTimeISO).getTime();
            const now = Date.now();
            let delay = Math.max(0, startTimestamp - now);
            if (hostSynchronizedCountdownInterval) {
                clearInterval(hostSynchronizedCountdownInterval);
                hostSynchronizedCountdownInterval = null;
            }
            hostSynchronizedCountdownInterval = setInterval(() => {
                const now2 = Date.now();
                const secondsLeft = Math.ceil((startTimestamp - now2) / 1000);
                countdownElement.textContent = Math.max(0, secondsLeft);
                // Switch to question preview when 5 seconds remain
                if (secondsLeft <= 5) {
                    clearInterval(hostSynchronizedCountdownInterval);
                    hostSynchronizedCountdownInterval = null;
                    countdownScreen.classList.remove('active');
                    // Start the 5s question preview leading into live question
                    const remaining = Math.max(0, secondsLeft);
                    showQuestionPreview(Math.max(remaining, 5));
                }
            }, 250);
        }

        // Show question preview screen
        async function showQuestionPreview(durationSeconds = 5) {
            const previewScreen = document.getElementById('question-preview-screen');
            const question = quizQuestions[currentQuestionIndex];
            
            // Update question content
            previewScreen.querySelector('.quiz-title').textContent = question.title;
            previewScreen.querySelector('.question-counter').textContent = `${currentQuestionIndex + 1}/${quizQuestions.length}`;
            previewScreen.querySelector('.question-image').src = question.image;
            
            // Ensure player count and controls are hidden during question preview
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            
            previewScreen.classList.add('active');
            
            let previewCountdown = durationSeconds;
            // Compute a precise live start timestamp shared with players
            const liveStartTs = Date.now() + (durationSeconds * 1000);
            const liveStartISO = new Date(liveStartTs).toISOString();
            
            // Start preview timer bar animation
            const timerBar = document.getElementById('preview-timer-bar');
            timerBar.style.width = '100%';
            timerBar.style.transitionDuration = `${durationSeconds}s`;
            
            setTimeout(() => {
                timerBar.style.width = '0%';
            }, 100);
            
            // Update quiz state for players (include precise live start time)
            await GameDB.updateQuizState(currentGameCode, {
                phase: 'question-preview',
                currentQuestion: currentQuestionIndex,
                questionData: { ...question, liveStartISO, totalQuestions: quizQuestions.length },
                countdown: previewCountdown
            });
            
            const previewInterval = setInterval(async () => {
                previewCountdown--;
                console.log('üïê Preview countdown:', previewCountdown);
                
                if (previewCountdown > 0) {
                    // Update countdown for players
                    await GameDB.updateQuizState(currentGameCode, {
                        phase: 'question-preview',
                        currentQuestion: currentQuestionIndex,
                        questionData: { ...question, liveStartISO, totalQuestions: quizQuestions.length },
                        countdown: previewCountdown
                    });
                } else {
                    console.log('üéØ Preview countdown finished! Transitioning to live question...');
                    clearInterval(previewInterval);
                    previewScreen.classList.remove('active');
                    
                    // Calculate delay for precise timing, but cap it at 2 seconds max to prevent hanging
                    const delayMs = Math.max(0, Math.min(2000, liveStartTs - Date.now()));
                    console.log('‚è∞ Calculated delay for live start:', delayMs, 'ms');
                    
                    if (delayMs > 0) {
                        setTimeout(() => {
                            console.log('üöÄ Starting live question via timeout...');
                            showLiveQuestion();
                        }, delayMs);
                    } else {
                        // Start immediately if delay is 0 or negative
                        console.log('üöÄ Starting live question immediately...');
                        showLiveQuestion();
                    }
                    
                    // Fallback: ensure live question starts within 3 seconds no matter what
                    setTimeout(() => {
                        console.log('üîÑ Fallback check: ensuring live question started...');
                        const currentActiveScreen = document.querySelector('.quiz-screen.active');
                        if (currentActiveScreen && currentActiveScreen.id !== 'live-question-screen') {
                            console.warn('üö® Live question not active, forcing transition!');
                            showLiveQuestion();
                        }
                    }, 3000);
                }
            }, 1000);
        }

        // Show live question screen
        async function showLiveQuestion() {
            const liveScreen = document.getElementById('live-question-screen');
            const question = quizQuestions[currentQuestionIndex];
            
            // Update question content
            liveScreen.querySelector('.quiz-title').textContent = question.title;
            liveScreen.querySelector('.question-counter').textContent = `${currentQuestionIndex + 1}/${quizQuestions.length}`;
            liveScreen.querySelector('.question-image').src = question.image;
            
            // Update answer options - handle variable option counts (1-4)
            const optionTexts = liveScreen.querySelectorAll('.option-text');
            const optionRows = liveScreen.querySelectorAll('.option-row');
            
            // Hide all options first
            optionTexts.forEach((text, index) => {
                const optionContainer = text.closest('.answer-option');
                if (optionContainer) {
                    optionContainer.style.display = 'none';
                }
            });
            
            // Show and populate only available options
            question.options.forEach((option, index) => {
                if (index < optionTexts.length) {
                    const optionContainer = optionTexts[index].closest('.answer-option');
                    if (optionContainer) {
                        optionContainer.style.display = 'flex';
                        optionTexts[index].textContent = option;
                    }
                }
            });
            
            // Adjust layout for fewer options
            if (question.options.length <= 2) {
                // For 1-2 options, center them in the first row
                optionRows[0].style.justifyContent = 'center';
                optionRows[1].style.display = 'none';
            } else {
                // For 3-4 options, use normal layout
                optionRows[0].style.justifyContent = 'space-between';
                optionRows[1].style.display = 'flex';
            }
            
            // Ensure player count and controls are hidden during live question
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            
            liveScreen.classList.add('active');
            // Mark game started when the question goes live
            try { await GameDB.updateGameSession(currentGameCode, { status: 'started' }); } catch (e) { console.warn('Failed to set started status:', e); }
            
            // Update quiz state for players
            await GameDB.updateQuizState(currentGameCode, {
                phase: 'live-question',
                currentQuestion: currentQuestionIndex,
                questionData: { ...question, totalQuestions: quizQuestions.length },
                timeLeft: QUIZ_CONFIG.questionTimeLimit
            });
            
            // Start question timer (configurable seconds for answering)
            let questionTime = QUIZ_CONFIG.questionTimeLimit;
            const timerElement = document.getElementById('question-timer');
            timerElement.textContent = questionTime;
            
            questionTimer = setInterval(async () => {
                questionTime--;
                if (questionTime > 0) {
                    timerElement.textContent = questionTime;
                    
                    // Play last countdown sound when 10 seconds remain
                    if (questionTime === 10 && lastCountdownSound) {
                        lastCountdownSound.currentTime = 0; // Reset to beginning
                        lastCountdownSound.play().catch(e => console.log('Last countdown sound blocked:', e));
                    }
                } else {
                    // Play time's up sound
                    if (timesUpSound) {
                        timesUpSound.currentTime = 0; // Reset to beginning
                        timesUpSound.play().catch(e => console.log('Times up sound blocked:', e));
                    }
                    
                    clearInterval(questionTimer);
                    liveScreen.classList.remove('active');
                    showQuestionResults();
                }
            }, 1000);
        }

        // Show question results
        async function showQuestionResults() {
            const resultsScreen = document.getElementById('quiz-results-screen');
            const question = quizQuestions[currentQuestionIndex];
            
            // Update quiz title with current question number
            const quizTitle = resultsScreen.querySelector('.quiz-title');
            if (quizTitle) {
                quizTitle.textContent = `Question ${currentQuestionIndex + 1}`;
                console.log('üéØ Updated host quiz title to:', `Question ${currentQuestionIndex + 1}`);
            }
            
            // Get answers from Supabase
            const answers = await GameDB.getQuestionAnswers(currentGameCode, currentQuestionIndex);
            
            // Count answers - handle variable option counts
            const maxOptions = question.options.length;
            const answerCounts = new Array(maxOptions).fill(0);
            answers.forEach(answer => {
                const index = answer.answer.charCodeAt(0) - 65; // Convert A=0, B=1, etc.
                if (index >= 0 && index < maxOptions) {
                    answerCounts[index]++;
                }
            });
            
            // Update answer bars - only show bars for available options
            const maxCount = Math.max(...answerCounts, 1);
            const optionLetters = ['a', 'b', 'c', 'd'];
            
            optionLetters.forEach((letter, index) => {
                const barElement = document.getElementById(`answer-${letter}-bar`);
                const countElement = document.getElementById(`answer-${letter}-count`);
                
                if (barElement && countElement) {
                    if (index < maxOptions) {
                        // Show and populate bar for available option
                        barElement.style.display = 'block';
                        const count = answerCounts[index];
                    const percentage = maxCount > 0 ? (count / maxCount) * 100 : 0;
                    barElement.style.height = `${percentage}%`;
                    countElement.textContent = count;
                    } else {
                        // Hide bar for unused option
                        barElement.style.display = 'none';
                        countElement.textContent = '0';
                    }
                }
            });
            
            // Update answer options with correct answer highlighting - handle variable option counts
            const resultOptionLetters = ['a', 'b', 'c', 'd'];
            resultOptionLetters.forEach((letter, index) => {
                const optionElement = document.getElementById(`result-option-${letter}`);
                const textElement = document.getElementById(`result-option-text-${letter}`);
                
                if (optionElement && textElement) {
                    if (index < question.options.length) {
                        // Show and populate option
                        optionElement.style.display = 'flex';
                    textElement.textContent = question.options[index];
                    
                    if (index === question.correct) {
                        optionElement.classList.add('correct');
                    } else {
                        optionElement.classList.remove('correct');
                        }
                    } else {
                        // Hide unused options
                        optionElement.style.display = 'none';
                    }
                }
            });
            
            // Ensure player count and controls are hidden during results
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            
            resultsScreen.classList.add('active');

            // Calculate and persist player scores (Kahoot-like scoring 500‚Äì1000)
            try {
                // Map player_id -> name
                const { data: playerRows } = await window.supabaseClient
                    .from('players')
                    .select('player_id, name')
                    .eq('game_code', currentGameCode);
                const idToName = (playerRows || []).reduce((acc, r) => { acc[r.player_id] = r.name; return acc; }, {});
                
                // Build score updates per name
                const questionTimeLimit = QUIZ_CONFIG.questionTimeLimit;
                const session = await GameDB.getGameSession(currentGameCode);
                const scores = session?.scores || {};
                
                // Create a set of players who answered this question
                const answeredPlayers = new Set();
                
                // Process submitted answers
                answers.forEach(a => {
                    const name = idToName[a.player_id];
                    if (!name) return;
                    answeredPlayers.add(name);
                    
                    const idx = ['A','B','C','D'].indexOf(a.answer);
                    const isCorrect = idx === question.correct;
                    let points = 0;
                    if (isCorrect) {
                        if (QUIZ_CONFIG.pointsConfig.timeBonus) {
                            const t = Math.min(Number(a.time_taken || 0), questionTimeLimit);
                            const basePoints = QUIZ_CONFIG.pointsConfig.minPoints;
                            const bonusPoints = QUIZ_CONFIG.pointsConfig.maxPoints - QUIZ_CONFIG.pointsConfig.minPoints;
                            points = Math.max(basePoints, Math.min(QUIZ_CONFIG.pointsConfig.maxPoints, 
                                Math.round((1 - (t / questionTimeLimit)) * bonusPoints + basePoints)));
                        } else {
                            points = QUIZ_CONFIG.pointsConfig.maxPoints;
                        }
                    }
                    scores[name] = (scores[name] || 0) + points;
                });
                
                // Handle players who didn't answer - mark as wrong and give 0 points
                Object.values(idToName).forEach(playerName => {
                    if (!answeredPlayers.has(playerName)) {
                        console.log(`‚è∞ Player ${playerName} didn't answer - marking as wrong with 0 points`);
                        scores[playerName] = (scores[playerName] || 0) + 0; // 0 points for no answer
                        
                        // Create a dummy answer record for unanswered players so they can see results
                        // This ensures all players transition to results page
                        GameDB.submitAnswer(currentGameCode, 'unanswered', currentQuestionIndex, 'X', questionTimeLimit)
                            .catch(e => console.warn('Failed to create dummy answer for unanswered player:', e));
                    }
                });
                
                await GameDB.updateGameSession(currentGameCode, { scores });
                console.log(`‚úÖ Processed scores for ${Object.keys(scores).length} players (including unanswered)`);
            } catch (e) {
                console.warn('Failed to persist scores:', e);
            }

            // Update quiz state for players; include question data so clients can compute their result text
            await GameDB.updateQuizState(currentGameCode, {
                phase: 'results',
                currentQuestion: currentQuestionIndex,
                questionData: { ...question, totalQuestions: quizQuestions.length }
            });
        }

        // Show scoreboard screen
        async function showScoreboard() {
            document.getElementById('quiz-results-screen').classList.remove('active');
            
            const scoreboardScreen = document.getElementById('scoreboard-screen');
            
            // Update quiz state for players
            await GameDB.updateQuizState(currentGameCode, {
                phase: 'scoreboard',
                currentQuestion: currentQuestionIndex
            });
            
            // Update player scores
            updatePlayerScores();
            
            // Ensure player count and controls are hidden during scoreboard
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            
            scoreboardScreen.classList.add('active');
        }

        // Update player scores (fetch players from players table, scores from game_sessions)
        async function updatePlayerScores() {
            try {
                const [session, playerRows] = await Promise.all([
                    GameDB.getGameSession(currentGameCode),
                    fetchPlayersFromTable(currentGameCode)
                ]);

                const scores = (session && session.scores) || {};
                const playerNames = (playerRows || []).map(p => p.name);

                const playerScores = playerNames.map(name => ({
                    name,
                    score: scores[name] || 0
                })).sort((a, b) => b.score - a.score);

                const playerScoresContainer = document.getElementById('player-scores');
                playerScoresContainer.innerHTML = '';

                if (playerScores.length === 0) {
                    playerScoresContainer.innerHTML = '<div class="no-scores">No player scores available</div>';
                    return;
                }

                playerScores.forEach((player, index) => {
                    const scoreItem = document.createElement('div');
                    scoreItem.className = `score-item rank-${index + 1}`;

                    let medalIcon = '';
                    if (index === 0) {
                        medalIcon = '<img src="assets/medal_1.png" alt="Gold Medal" class="medal-icon">';
                    } else if (index === 1) {
                        medalIcon = '<img src="assets/medal_2.png" alt="Silver Medal" class="medal-icon">';
                    } else if (index === 2) {
                        medalIcon = '<img src="assets/medal_3.png" alt="Bronze Medal" class="medal-icon">';
                    }

                    scoreItem.innerHTML = `
                        ${medalIcon}
                        <span class="player-name">${player.name}</span>
                        <span class="player-score">${player.score}</span>
                    `;

                    playerScoresContainer.appendChild(scoreItem);
                });
            } catch (error) {
                console.error('Error updating player scores:', error);
            }
        }

        // Proceed to next question
        async function proceedToNextQuestion() {
            document.getElementById('scoreboard-screen').classList.remove('active');
            
            currentQuestionIndex++;
            
            if (currentQuestionIndex < quizQuestions.length) {
                // IMMEDIATELY notify players of the transition
                console.log('üöÄ Host proceeding to next question. Immediately notifying players...');
                
                // 1. Broadcast immediate transition signal
                try {
                    await broadcastNextQuestion(currentQuestionIndex);
                } catch (e) {
                    console.warn('Failed to broadcast next question:', e);
                }
                
                // 2. Update game session with next question signal
                try {
                    await GameDB.updateGameSession(currentGameCode, {
                        next_question_signal: currentQuestionIndex,
                        updated_at: new Date().toISOString()
                    });
                } catch (e) {
                    console.warn('Failed to update game session with next question signal:', e);
                }
                
                // 3. Start the countdown as normal
                await startNextQuestionCountdown();
            } else {
                // Quiz ended - show final leaderboard
                showFinalLeaderboard();
            }
        }

        // Start 10-second countdown before next question
        async function startNextQuestionCountdown() {
            // For next questions, go directly to question preview with 10-second countdown
            // (Generic countdown screen is only for the very first question)
            
            // IMMEDIATELY update quiz state to ensure players get notified
            try {
                console.log('üîÑ Updating quiz state for next question transition...');
                await GameDB.updateQuizState(currentGameCode, {
                    phase: 'question-preview',
                    currentQuestion: currentQuestionIndex,
                    questionData: { ...quizQuestions[currentQuestionIndex], totalQuestions: quizQuestions.length },
                    countdown: 10
                });
                console.log('‚úÖ Quiz state updated for next question');
            } catch (error) {
                console.error('‚ùå Failed to update quiz state for next question:', error);
            }
            
            showQuestionPreview(10);
        }

        // Show final leaderboard with celebration
        async function showFinalLeaderboard() {
            document.getElementById('scoreboard-screen').classList.remove('active');
            
            const finalScreen = document.getElementById('final-leaderboard-screen');
            
            // IMMEDIATELY broadcast final results transition to players
            try {
                await broadcastFinalResults();
            } catch (e) {
                console.warn('Failed to broadcast final results:', e);
            }
            
            // Update quiz state for players
            await GameDB.updateQuizState(currentGameCode, {
                phase: 'final-results'
            });
            
            // Ensure player count and controls are hidden during final leaderboard
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            
            finalScreen.classList.add('active');
            
            // Play crowds sound effect for celebration
            if (crowdsSound) {
                crowdsSound.currentTime = 0; // Reset to beginning
                crowdsSound.play().catch(e => console.log('Crowds sound blocked:', e));
            }
            
            // Start confetti animation
            createConfetti();
            
            // Update final scores
            updateFinalPodium();
        }

        // Broadcast next question signal to players
        async function broadcastNextQuestion(questionIndex) {
            console.log('üì° Broadcasting next question signal to players:', questionIndex);
            console.log('üì° Using game code:', currentGameCode);
            
            // Use Supabase broadcast channel for immediate communication
            try {
                const channelName = `next_question_${currentGameCode}`;
                console.log('üì° Creating broadcast channel:', channelName);
                
                const channel = window.supabaseClient.channel(channelName, { 
                    config: { broadcast: { self: true } } 
                });
                
                await channel.subscribe((status) => {
                    console.log('üì° Next question broadcast channel status:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('‚úÖ Broadcast channel subscribed successfully');
                    }
                });
                
                const payload = {
                    game_code: currentGameCode,
                    question_index: questionIndex,
                    timestamp: Date.now()
                };
                
                console.log('üì° Sending broadcast payload:', payload);
                
                await channel.send({
                    type: 'broadcast',
                    event: 'next_question',
                    payload: payload
                });
                
                console.log('‚úÖ Next question broadcast sent successfully');
                console.log('üì° Players should now receive the signal and transition to countdown');
                
                // Clean up channel after a short delay
                setTimeout(() => {
                    console.log('üßπ Cleaning up broadcast channel');
                    window.supabaseClient.removeChannel(channel);
                }, 2000);
                
            } catch (error) {
                console.error('‚ùå Failed to broadcast next question:', error);
                console.error('‚ùå Error details:', error.message, error.stack);
                throw error;
            }
        }

        // Broadcast final results signal to players
        async function broadcastFinalResults() {
            console.log('üì° Broadcasting final results signal to players');
            console.log('üì° Using game code:', currentGameCode);
            
            // Use Supabase broadcast channel for immediate communication
            try {
                const channelName = `final_results_${currentGameCode}`;
                console.log('üì° Creating broadcast channel:', channelName);
                
                const channel = window.supabaseClient.channel(channelName, { 
                    config: { broadcast: { self: true } } 
                });
                
                await channel.subscribe((status) => {
                    console.log('üì° Final results broadcast channel status:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('‚úÖ Final results broadcast channel subscribed successfully');
                    }
                });
                
                const payload = {
                    game_code: currentGameCode,
                    timestamp: Date.now()
                };
                
                console.log('üì° Sending final results broadcast payload:', payload);
                
                await channel.send({
                    type: 'broadcast',
                    event: 'final_results',
                    payload: payload
                });
                
                console.log('‚úÖ Final results broadcast sent successfully');
                console.log('üì° Players should now receive the signal and transition to final results');
                
                // Clean up channel after a short delay
                setTimeout(() => {
                    console.log('üßπ Cleaning up final results broadcast channel');
                    window.supabaseClient.removeChannel(channel);
                }, 2000);
                
            } catch (error) {
                console.error('‚ùå Failed to broadcast final results:', error);
                console.error('‚ùå Error details:', error.message, error.stack);
                throw error;
            }
        }

        // Create confetti animation
        function createConfetti() {
            const duration = 15000; // 15 seconds
            const animationEnd = Date.now() + duration;
            const defaults = {
                startVelocity: 30,
                spread: 360,
                ticks: 100,
                zIndex: 9999
            };

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            const interval = setInterval(function() {
                if (Date.now() > animationEnd) {
                    return clearInterval(interval);
                }

                confetti(Object.assign({}, defaults, {
                    particleCount: 5,
                    origin: {
                        x: Math.random(),
                        y: -0.1
                    },
                    colors: ['#ff595e', '#ffca3a', '#8ac926', '#1982c4', '#6a4c93']
                }));
            }, 250);
        }

        // Update final podium with top 3 players
        async function updateFinalPodium() {
            try {
                console.log('üèÜ Updating final podium for game:', currentGameCode);
                
                // Get both session data (for scores) and player data
                const [session, playerRows] = await Promise.all([
                    GameDB.getGameSession(currentGameCode),
                    fetchPlayersFromTable(currentGameCode)
                ]);
                
                console.log('üìä Session data:', session);
                console.log('üë• Player rows:', playerRows);
                
                let finalScores = [];
                
                if (session && session.scores && playerRows && playerRows.length > 0) {
                    // Create final scores array from players table and session scores
                    finalScores = playerRows.map(player => {
                        const score = session.scores[player.name] || 0;
                        console.log(`üìà Player ${player.name}: ${score} points`);
                        return {
                            name: player.name,
                            score: score
                        };
                    }).sort((a, b) => b.score - a.score).slice(0, 3);
                    
                    console.log('üéØ Final scores (top 3):', finalScores);
                } else {
                    console.warn('‚ö†Ô∏è Missing session scores or player data');
                    console.log('Session scores:', session?.scores);
                    console.log('Player rows:', playerRows);
                }
                
                // Default empty podium if no players
                const defaultPlayers = [
                    { name: '-', score: 0 },
                    { name: '-', score: 0 },
                    { name: '-', score: 0 }
                ];
                
                // Fill missing positions with default values
                while (finalScores.length < 3) {
                    finalScores.push(defaultPlayers[finalScores.length]);
                }
                
                console.log('üèÖ Final podium data:', finalScores);
                
                // Update winner (1st place)
                const firstPlace = document.querySelector('.first-place');
                if (firstPlace) {
                    firstPlace.querySelector('.podium-name').textContent = finalScores[0].name;
                    firstPlace.querySelector('.podium-score').textContent = finalScores[0].score;
                    console.log('ü•á 1st place updated:', finalScores[0]);
                }
                
                // Update 2nd place
                const secondPlace = document.querySelector('.second-place');
                if (secondPlace) {
                    secondPlace.querySelector('.podium-name').textContent = finalScores[1].name;
                    secondPlace.querySelector('.podium-score').textContent = finalScores[1].score;
                    console.log('ü•à 2nd place updated:', finalScores[1]);
                }
                
                // Update 3rd place
                const thirdPlace = document.querySelector('.third-place');
                if (thirdPlace) {
                    thirdPlace.querySelector('.podium-name').textContent = finalScores[2].name;
                    thirdPlace.querySelector('.podium-score').textContent = finalScores[2].score;
                    console.log('ü•â 3rd place updated:', finalScores[2]);
                }
                
                console.log('‚úÖ Final podium update complete!');
            } catch (error) {
                console.error('‚ùå Error updating final podium:', error);
            }
        }

        // Play again function
        async function playAgain() {
            document.getElementById('final-leaderboard-screen').classList.remove('active');
            
            console.log('üîÑ Play Again: Starting fresh game...');
            
            try {
                // Clean up current game completely (remove all players and data)
                console.log('üßπ Cleaning up current game:', currentGameCode);
                await GameDB.cleanupExistingGame(currentGameCode);
                
                // Clean up subscriptions for the old game
                cleanupSubscriptions();
                cleanupReactionSystem();
                
                // Reset all game state
                players = [];
                gameStarted = false;
                currentQuestionIndex = 0;
                
                // Force immediate UI update to show no players
                console.log('üîÑ Updating UI to show no players...');
                updatePlayersDisplay();
                updatePlayerCount();
                updateStartButton();
                
                // Generate a new game code and create new session
                console.log('üéÆ Generating new game code...');
                await generateGameCode();
                
                // Reinitialize reaction system for new game
                initializeReactionSystem(currentGameCode);
                
                // Reset to waiting room with new game
                resetToWaitingRoom();
                
                // Ensure player count and controls are visible in new game
                document.getElementById('player-count-container').style.display = 'block';
                document.getElementById('controls-container').style.display = 'block';
                
                console.log('‚úÖ New game created with code:', currentGameCode);
                
            } catch (error) {
                console.error('‚ùå Error creating new game:', error);
                alert('Error creating new game. Please refresh the page.');
            }
        }

        // Reset back to waiting room
        async function resetToWaitingRoom() {
            document.querySelectorAll('.quiz-screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            document.querySelector('.main-container').style.display = 'flex';
            document.querySelector('.header').style.display = 'flex';
            document.getElementById('player-count-container').style.display = 'block';
            document.getElementById('controls-container').style.display = 'block';
            
            gameStarted = false;
            currentQuestionIndex = 0;
            
            // Clear player scores from session
            try {
                await GameDB.updateGameSession(currentGameCode, {
                    scores: {},
                    status: 'waiting'
                });
            } catch (error) {
                console.error('Error resetting game session:', error);
            }
            
            // Update UI to show no players
            updatePlayersDisplay();
            updatePlayerCount();
            updateStartButton();
        }

        // Initialize music with default soundtrack
        function initializeMusic() {
            backgroundMusic = new Audio('assets/soundtrack/Answer That Now!.mp3');
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.5;
            
            // Load saved music state from localStorage (default to off)
            const savedMusicState = localStorage.getItem('quitize_music_on');
            if (savedMusicState !== null) {
                isMusicOn = savedMusicState === 'true';
            } else {
                // Default to music off for first-time users
                isMusicOn = false;
            }
            
            // Update icon to reflect current state (default to music off)
            if (!isMusicOn) {
                document.getElementById('music-icon').src = 'assets/music_off.png';
            } else {
                document.getElementById('music-icon').src = 'assets/music_on.png';
                document.getElementById('music-icon').classList.add('playing');
            }
            
            // Start playing music only if it was previously turned on
            if (isMusicOn) {
                backgroundMusic.play().catch(e => console.log('Music autoplay blocked:', e));
            }
        }

        // Initialize sound effects
        function initializeSoundEffects() {
            gameStartSound = new Audio('assets/soundeffect/gamestart.mp3');
            lastCountdownSound = new Audio('assets/soundeffect/lastcountdown.MP3');
            timesUpSound = new Audio('assets/soundeffect/timesup.mp3');
            crowdsSound = new Audio('assets/soundeffect/crowds.mp3');
            
            // Set volumes
            gameStartSound.volume = 0.7;
            lastCountdownSound.volume = 0.8;
            timesUpSound.volume = 0.8;
            crowdsSound.volume = 0.6;
        }

        // Toggle music on/off
        function toggleMusic() {
            const musicIcon = document.getElementById('music-icon');
            
            if (isMusicOn) {
                backgroundMusic.pause();
                musicIcon.src = 'assets/music_off.png';
                musicIcon.classList.remove('playing');
                isMusicOn = false;
                // Save music state to localStorage
                localStorage.setItem('quitize_music_on', 'false');
            } else {
                backgroundMusic.play();
                musicIcon.src = 'assets/music_on.png';
                musicIcon.classList.add('playing');
                isMusicOn = true;
                // Save music state to localStorage
                localStorage.setItem('quitize_music_on', 'true');
            }
        }

        // Toggle fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Error attempting to enable fullscreen:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Initialize controls event listeners
        function initializeControls() {
            // Music toggle
            document.getElementById('music-icon').addEventListener('click', toggleMusic);
            
            // Fullscreen toggle
            document.querySelector('.fullscreen-icon').addEventListener('click', toggleFullscreen);
        }

        // Live Reaction System
        let reactionChannel = null;
        let activeReactions = 0;
        const MAX_ACTIVE_REACTIONS = 50; // Limit simultaneous floating reactions for performance
        
        function initializeReactionSystem(gameCode) {
            console.log('üéâ Initializing reaction system for game:', gameCode);
            
            if (reactionChannel) {
                window.supabaseClient.removeChannel(reactionChannel);
            }
            
            const channelName = `reactions_${gameCode}`;
            reactionChannel = window.supabaseClient.channel(channelName, {
                config: { broadcast: { self: false } }
            });
            
            reactionChannel.on('broadcast', { event: 'reaction' }, (payload) => {
                console.log('üéâ Received reaction:', payload.payload);
                handleReaction(payload.payload);
            });
            
            reactionChannel.subscribe((status) => {
                console.log('üéâ Reaction channel status:', status);
            });
        }
        
        function handleReaction(reactionData) {
            const { emoji, playerName, burst } = reactionData;
            createFloatingReaction(emoji, burst);
            console.log(`üéâ ${playerName} sent ${emoji}${burst ? ' (burst!)' : ''}`);
        }
        
        function getReactionImagePath(reactionType) {
            const reactionMap = {
                'clap': 'assets/livereaction/clap.png',
                'heart': 'assets/livereaction/heart.png',
                'confetti': 'assets/livereaction/confetti.png'
            };
            return reactionMap[reactionType] || 'assets/livereaction/clap.png';
        }
        
        function createFloatingReaction(reactionType, isBurst = false) {
            // Performance optimization: limit active reactions
            if (activeReactions >= MAX_ACTIVE_REACTIONS) {
                console.log('Max reactions reached, skipping');
                return;
            }
            
            const reactionsDisplay = document.getElementById('reactions-display');
            if (!reactionsDisplay) return;
            
            activeReactions++;
            
            const reaction = document.createElement('div');
            reaction.className = `floating-reaction${isBurst ? ' burst' : ''}`;
            
            // Create image element for the reaction
            const img = document.createElement('img');
            img.src = getReactionImagePath(reactionType);
            img.alt = reactionType;
            img.className = 'floating-reaction-image';
            reaction.appendChild(img);
            
            // Position reaction at bottom left area (near player count)
            const startX = Math.random() * 300 + 50; // Random X between 50-350px from left
            const startY = window.innerHeight - 100; // Start near bottom
            
            reaction.style.left = startX + 'px';
            reaction.style.top = startY + 'px';
            
            // Add random horizontal drift
            const drift = (Math.random() - 0.5) * 200;
            reaction.style.setProperty('--drift', drift + 'px');
            
            reactionsDisplay.appendChild(reaction);
            
            // Remove reaction after animation completes
            const duration = isBurst ? 2500 : 3000;
            setTimeout(() => {
                if (reaction.parentNode) {
                    reaction.parentNode.removeChild(reaction);
                    activeReactions = Math.max(0, activeReactions - 1);
                }
            }, duration);
        }
        
        // Clean up reaction system
        function cleanupReactionSystem() {
            if (reactionChannel) {
                window.supabaseClient.removeChannel(reactionChannel);
                reactionChannel = null;
            }
        }



        // Initialize the game
        async function initializeGame() {
            try {
                // Initialize Gametize configuration first
                initializeGametizeConfig();
                
                // Clean up old games first
                await GameDB.cleanupOldGames();
                
                await generateGameCode();
                updatePlayersDisplay();
                updatePlayerCount();
                updateStartButton();
                
                // Initialize reaction system
                initializeReactionSystem(currentGameCode);
                
                // Start listening for players joining
                startPlayerListener();
                // Periodic refresh for player list (fallback for real-time)
                setInterval(updatePlayerListFromSession, 3000);
                
                // Initialize music, sound effects and controls
                initializeMusic();
                initializeSoundEffects();
                initializeControls();

                // Fetch questions from API on load
                await fetchQuizQuestions();

            } catch (error) {
                console.error('Error during game initialization:', error);
                alert('Failed to initialize game. Please refresh the page and try again.');
            }
        }

        // Handle keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' || event.key === ' ') {
                if (!document.getElementById('start-btn').disabled) {
                    startGame();
                }
            }
            
            // Music toggle with 'M' key
            if (event.key.toLowerCase() === 'm') {
                toggleMusic();
            }
            
            // Fullscreen toggle with 'F' key
            if (event.key.toLowerCase() === 'f') {
                toggleFullscreen();
            }
            

        });

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            cleanupSubscriptions();
        });

        // Initialize when page loads
        window.addEventListener('load', function() {
            console.log('üöÄ Page loaded, starting initialization...');
            
            // Function to try initialization with retries
            function tryInitialize(retries = 3) {
                try {
                    console.log(`üîÑ Attempt ${4 - retries}/3 to initialize...`);
                    initializeGame();
                } catch (error) {
                    console.error(`‚ùå Attempt ${4 - retries}/3 failed:`, error);
                    
                    if (retries > 1) {
                        console.log(`üîÑ Retrying in 500ms... (${retries - 1} retries left)`);
                        setTimeout(() => tryInitialize(retries - 1), 500);
                    } else {
                        console.error('‚ùå All initialization attempts failed');
                        alert('Failed to initialize game after multiple attempts: ' + error.message);
                    }
                }
            }
            
            // Start with a delay to ensure all scripts are loaded
            setTimeout(() => {
                tryInitialize();
            }, 200);
        });
    </script>
</body>
</html> 