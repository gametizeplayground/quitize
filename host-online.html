<!DOCTYPE html>
<!--
GAMETIZE HISTORY & FUN FACTS QUIZ - HOST INTERFACE
================================================

To modify the quiz:
1. Update the quiz title in the head section (around line 62)
2. Edit the 'quizQuestions' array (around line 260)
3. Add/remove questions with title, image, options, correct answer index, and explanation
4. Update QUIZ_CONFIG settings for timing and scoring (around line 304)
5. Add corresponding images to assets/questions image/ folder (1.webp, 2.webp, etc.)

Player interface will automatically show simple A/B/C/D buttons.
Host interface displays full question content and images.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quitize - Host Dashboard</title>
    <link rel="stylesheet" href="hoststyles.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4CAF50">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config.js"></script>
</head>
<body>
    <div class="header">
        <img src="assets/logo.png" alt="Quitize Logo" class="logo">
    </div>

    <div class="main-container">
        <!-- Game Code Card moved to top center -->
        <div class="game-code-card">
            <div class="code-section">
                <div class="game-key-label">GAME CODE</div>
                <div class="game-code" id="display-game-code">255 8657</div>
            </div>
            <div class="qr-section">
                <div class="qr-code">
                    <img id="qr-code-image" src="" alt="QR Code" />
                </div>
            </div>
        </div>

        <!-- Players section in the middle -->
        <div class="players-section">
            <div class="players-grid" id="players-grid">
                <!-- Players will be added here dynamically -->
            </div>
            <div class="no-players" id="no-players" style="display: block;">
                No players joined yet
            </div>
        </div>

        <!-- Start button moved to bottom -->
        <button class="start-button" id="start-btn" onclick="startGame()" disabled>
            Start Game
        </button>
    </div>

    <!-- Live Reactions Display Area -->
    <div class="reactions-display" id="reactions-display">
        <!-- Floating reactions will appear here -->
    </div>

    <!-- Player count moved to bottom right -->
    <div class="player-count-bottom" id="player-count-container">
        <span id="player-count">0</span> players
    </div>

    <!-- Music and Fullscreen Controls -->
    <div class="controls-bottom" id="controls-container">
        <div class="control-pill">
            <img src="assets/music_off.png" alt="Music Off" id="music-icon" class="control-icon" title="Toggle Music (M)">
            <img src="assets/fullscreen.png" alt="Fullscreen" class="control-icon fullscreen-icon" title="Toggle Fullscreen (F)">
        </div>
    </div>

    <!-- Quiz Countdown Screen -->
    <div class="quiz-screen" id="quiz-countdown-screen">
        <div class="quiz-header">
            <div class="quiz-title">GAMETIZE HISTORY & FUN FACTS</div>
        </div>
        <div class="countdown-circle">
                <span id="quiz-countdown">10</span>
        </div>
    </div>

    <!-- Question Preview Screen -->
    <div class="quiz-screen" id="question-preview-screen">
        <div class="quiz-header">
            <div class="quiz-title">What colour is watermelon?</div>
            <div class="question-counter">1/10</div>
        </div>
        <div class="question-image-container">
            <img src="https://images.unsplash.com/photo-1587822863-4d0a812c7b8f?w=400&h=300&fit=crop" alt="Watermelon" class="question-image">
        </div>
        <div class="timer-bar-container">
            <div class="timer-bar" id="preview-timer-bar"></div>
        </div>
    </div>

    <!-- Live Quiz Question Screen -->
    <div class="quiz-screen" id="live-question-screen">
        <div class="quiz-header">
            <div class="quiz-title" id="live-question-text">What colour is watermelon?</div>
            <div class="question-counter" id="live-question-counter">1/10</div>
        </div>
        <div class="question-content">
            <div class="timer-section">
                <div class="timer-circle">
                    <span id="question-timer">20</span>
                </div>
            </div>
            <div class="question-main">
                <div class="question-image-container">
                    <img src="https://images.unsplash.com/photo-1587822863-4d0a812c7b8f?w=400&h=300&fit=crop" alt="Watermelon" class="question-image" id="live-question-image">
                </div>
                <div class="answer-options">
                    <div class="option-row">
                        <div class="answer-option option-a">
                            <span class="option-letter">A</span>
                            <span class="option-text">Yellow</span>
                        </div>
                        <div class="answer-option option-b">
                            <span class="option-letter">B</span>
                            <span class="option-text">Red</span>
                        </div>
                    </div>
                    <div class="option-row">
                        <div class="answer-option option-c">
                            <span class="option-letter">C</span>
                            <span class="option-text">White</span>
                        </div>
                        <div class="answer-option option-d">
                            <span class="option-letter">D</span>
                            <span class="option-text">Green</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Quiz Results Screen -->
    <div class="quiz-screen" id="quiz-results-screen">
        <div class="results-header">
            <h1 class="quiz-title">Quiz 1</h1>
        </div>
        
        <div class="results-content">
            <div class="results-answers">
                <div class="answer-bar">
                    <div class="answer-bar-chart" id="answer-a-bar" style="height: 0%">
                        <div class="answer-count" id="answer-a-count">0</div>
                    </div>
                    <div class="answer-label">A</div>
                </div>
                <div class="answer-bar">
                    <div class="answer-bar-chart" id="answer-b-bar" style="height: 0%">
                        <div class="answer-count" id="answer-b-count">0</div>
                    </div>
                    <div class="answer-label">B</div>
                </div>
                <div class="answer-bar">
                    <div class="answer-bar-chart" id="answer-c-bar" style="height: 0%">
                        <div class="answer-count" id="answer-c-count">0</div>
                    </div>
                    <div class="answer-label">C</div>
                </div>
                <div class="answer-bar">
                    <div class="answer-bar-chart" id="answer-d-bar" style="height: 0%">
                        <div class="answer-count" id="answer-d-count">0</div>
                    </div>
                    <div class="answer-label">D</div>
                </div>
            </div>
            
            <div class="answer-results">
                <div class="result-option-row">
                    <div class="result-option result-option-a" id="result-option-a">
                        <div class="result-letter">A</div>
                        <div class="result-option-text" id="result-option-text-a">Yellow</div>
                    </div>
                    <div class="result-option result-option-b" id="result-option-b">
                        <div class="result-letter">B</div>
                        <div class="result-option-text" id="result-option-text-b">Red</div>
                    </div>
                </div>
                <div class="result-option-row">
                    <div class="result-option result-option-c" id="result-option-c">
                        <div class="result-letter">C</div>
                        <div class="result-option-text" id="result-option-text-c">White</div>
                    </div>
                    <div class="result-option result-option-d" id="result-option-d">
                        <div class="result-letter">D</div>
                        <div class="result-option-text" id="result-option-text-d">Green</div>
                    </div>
                </div>
            </div>
        </div>
        
        <button class="next-button" onclick="showScoreboard()">Next</button>
    </div>

    <!-- Scoreboard Screen -->
    <div class="quiz-screen" id="scoreboard-screen">
        <div class="scoreboard-header">
            <div class="scoreboard-title">Scoreboard</div>
        </div>
        <div class="scoreboard-content">
            <div class="player-scores" id="player-scores">
                <!-- Player scores will be populated dynamically -->
            </div>
        </div>
        <button class="next-button" onclick="proceedToNextQuestion()">Next</button>
    </div>

    <!-- Final Leaderboard Screen -->
    <div class="quiz-screen" id="final-leaderboard-screen">
        <div class="final-header">
            <img src="assets/logo.png" alt="Quitize Logo" class="logo">
            <button class="play-again-button" onclick="playAgain()">Play Again</button>
        </div>

        <div class="podium-container">
            <!-- 2nd Place -->
            <div class="podium-player second-place">
                <div class="medal-container">
                    <img src="assets/medal_2.png" alt="Silver Medal" class="medal-image">
                </div>
                <div class="podium-info">
                    <div class="podium-rank">2</div>
                    <div class="podium-name">-</div>
                    <div class="podium-score">0</div>
                </div>
            </div>

            <!-- 1st Place (Winner) -->
            <div class="podium-player first-place">
                <div class="medal-container">
                    <img src="assets/medal_1.png" alt="Gold Medal" class="medal-image">
                </div>
                <div class="podium-info">
                    <div class="podium-rank winner-rank">1</div>
                    <div class="podium-name">-</div>
                    <div class="podium-score">0</div>
                </div>
            </div>

            <!-- 3rd Place -->
            <div class="podium-player third-place">
                <div class="medal-container">
                    <img src="assets/medal_3.png" alt="Bronze Medal" class="medal-image">
                </div>
                <div class="podium-info">
                    <div class="podium-rank">3</div>
                    <div class="podium-name">-</div>
                    <div class="podium-score">0</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let players = [];
        let gameCode = '';
        let currentGameCode = '';
        let gameStarted = false;
        let currentQuestionIndex = 0;
        let questionTimer;
        let isMusicOn = false;
        let backgroundMusic;
        
        // Sound effects
        let gameStartSound;
        let lastCountdownSound;
        let timesUpSound;
        let crowdsSound;

        // ============================================================
        // GAMETIZE HISTORY & FUN FACTS QUIZ
        // ============================================================
        // To add/modify questions:
        // 1. Update the quizQuestions array below
        // 2. Add corresponding question images to assets/questions image/ folder
        // 3. Update the image path to match the question number (1.png, 2.png, etc.)
        // 4. Set the correct answer index (0=A, 1=B, 2=C, 3=D)
        // ============================================================
        
        const quizQuestions = [
            {
                title: "In which year was Gametize officially founded?",
                image: "assets/questions image/1.webp",
                options: ["2005", "2009", "2011", "2014"],
                correct: 1, // B) 2009
                explanation: "Gametize was officially founded in 2009."
            },
            {
                title: "Gametize started as a project in a university hackathon before becoming a company.",
                image: "assets/questions image/2.webp",
                options: ["True", "False"],
                correct: 0, // A) True
                explanation: "Yes, Gametize started as a hackathon project before becoming a company."
            }
        ];
        
        // Configuration settings for easy customization
        const QUIZ_CONFIG = {
            questionTimeLimit: 20, // seconds per question
            previewCountdown: 10,  // seconds for question preview
            resultsDisplayTime: 5, // seconds to show results
            pointsConfig: {
                maxPoints: 1000,
                minPoints: 500,
                timeBonus: true // award bonus points for faster answers
            }
        };

        // Generate random game code
        async function generateGameCode() {
            let attempts = 0;
            const maxAttempts = 10;
            
            // Keep generating until we find a unique code
            do {
                gameCode = Math.floor(100000 + Math.random() * 900000).toString();
                attempts++;
                
                if (attempts > maxAttempts) {
                    alert('Unable to generate a unique game code. Please try again.');
                    return;
                }
                
                // Check if this code already exists
                try {
                    const exists = await GameDB.gameCodeExists(gameCode);
                    if (!exists) break; // Found a unique code
                    console.log(`Game code ${gameCode} already exists, generating new one...`);
                } catch (error) {
                    console.warn('Error checking game code existence:', error);
                    break; // Continue with this code if check fails
                }
            } while (attempts <= maxAttempts);
            
            // Format with space for display
            const formattedCode = gameCode.slice(0, 3) + ' ' + gameCode.slice(3);
            document.getElementById('display-game-code').textContent = formattedCode;
            
            // Initialize game session in Supabase
            currentGameCode = gameCode;
            try {
                await GameDB.createGameSession(gameCode);
                // Initialize real-time subscriptions
                initializeGameSubscriptions(gameCode);
                console.log('Game session created successfully with code:', gameCode);
            } catch (error) {
                console.error('Failed to create game session:', error);
                alert('Failed to create game session. Please try again.');
                return;
            }
            
            // Generate QR code for the game
            generateQRCode();
            
            return gameCode;
        }

        // Generate QR Code for the game
        function generateQRCode() {
            // Construct the game URL with the current domain and game code
            const baseURL = window.location.origin;
            const gameURL = `${baseURL}/player-online.html?code=${currentGameCode}`;
            
            // Use QR Server API to generate the QR code
            const qrCodeURL = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(gameURL)}`;
            
            const qrCodeImage = document.getElementById('qr-code-image');
            qrCodeImage.src = qrCodeURL;
            qrCodeImage.style.width = '100%';
            qrCodeImage.style.height = '100%';
            qrCodeImage.style.objectFit = 'contain';
            qrCodeImage.style.borderRadius = '8px';
            
            // Add click handler to copy URL
            qrCodeImage.onclick = function() {
                copyToClipboard(gameURL);
                showMessage('Game URL copied to clipboard!');
            };
            
            // Add error handling
            qrCodeImage.onerror = function() {
                console.error('Failed to load QR code');
                qrCodeImage.style.backgroundColor = '#f0f0f0';
                qrCodeImage.style.display = 'flex';
                qrCodeImage.style.alignItems = 'center';
                qrCodeImage.style.justifyContent = 'center';
                qrCodeImage.style.fontSize = '12px';
                qrCodeImage.style.color = '#666';
                qrCodeImage.alt = 'QR Code unavailable';
            };
            
            // Domain information for reference
            const domain = window.location.hostname === 'localhost' ? 'quitize.game' : window.location.hostname;
            
            console.log('QR Code generated for URL:', gameURL);
        }

        // Copy text to clipboard
        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).catch(err => {
                    console.error('Failed to copy: ', err);
                    fallbackCopyTextToClipboard(text);
                });
            } else {
                fallbackCopyTextToClipboard(text);
            }
        }

        // Fallback copy method for older browsers
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
            }
            document.body.removeChild(textArea);
        }

        // Show temporary message
        function showMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = message;
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '20px';
            messageDiv.style.right = '20px';
            messageDiv.style.background = '#4fc3a3';
            messageDiv.style.color = 'white';
            messageDiv.style.padding = '10px 20px';
            messageDiv.style.borderRadius = '25px';
            messageDiv.style.zIndex = '1000';
            messageDiv.style.fontSize = '14px';
            messageDiv.style.fontWeight = '500';
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 3000);
        }

        // Add this function to fetch players from the players table
        async function fetchPlayersFromTable(gameCode) {
            const { data, error } = await window.supabaseClient
                .from('players')
                .select('*')
                .eq('game_code', gameCode);

            if (error) {
                console.error('Error fetching players:', error);
                return [];
            }
            return data;
        }

        // Cleanup inactive players (those who haven't been seen for more than 60 seconds)
        async function cleanupInactivePlayers() {
            try {
                const oneMinuteAgo = new Date(Date.now() - 60000).toISOString();
                
                // Find inactive players
                const { data: inactivePlayers, error } = await window.supabaseClient
                    .from('players')
                    .select('*')
                    .eq('game_code', currentGameCode)
                    .lt('last_seen', oneMinuteAgo);
                
                if (error) {
                    console.error('Error finding inactive players:', error);
                    return;
                }
                
                // Remove inactive players
                if (inactivePlayers && inactivePlayers.length > 0) {
                    console.log(`Removing ${inactivePlayers.length} inactive players:`, inactivePlayers.map(p => p.name));
                    
                    for (const player of inactivePlayers) {
                        await GameDB.removePlayer(currentGameCode, player.player_id);
                    }
                }
            } catch (error) {
                console.error('Error cleaning up inactive players:', error);
            }
        }

        // Update player list from Supabase
        async function updatePlayerListFromSession() {
            try {
                console.log('Fetching players for game code:', currentGameCode);
                
                // First, cleanup inactive players
                await cleanupInactivePlayers();
                
                const playerRows = await fetchPlayersFromTable(currentGameCode);
                console.log('Fetched player rows:', playerRows);
                const newPlayers = playerRows.map(p => p.name);
                // Only update if there are actual changes
                if (JSON.stringify(players) !== JSON.stringify(newPlayers)) {
                    players = newPlayers;
                    // Update the player count and list
                    const playerCount = players.length;
                    document.getElementById('player-count').textContent = playerCount;
                    // Update the players display
                    updatePlayersDisplay();
                    updateStartButton();
                }
            } catch (error) {
                console.error('Error updating player list:', error);
            }
        }

        // Listen for player changes
        function startPlayerListener() {
            // Listen for custom events from Supabase subscriptions
            window.addEventListener('gameSessionUpdated', function(e) {
                if (e.detail.gameCode === currentGameCode) {
                    updatePlayerListFromSession();
                }
            });

            window.addEventListener('playerJoined', function(e) {
                console.log('Player joined:', e.detail.player);
                updatePlayerListFromSession();
            });

            window.addEventListener('playerLeft', function(e) {
                console.log('Player left:', e.detail.player);
                updatePlayerListFromSession();
            });
        }

        // Update the players display
        function updatePlayersDisplay() {
            const playersGrid = document.getElementById('players-grid');
            const noPlayersMsg = document.getElementById('no-players');
            
            playersGrid.innerHTML = '';
            
            if (players.length === 0) {
                noPlayersMsg.style.display = 'block';
            } else {
                noPlayersMsg.style.display = 'none';
                players.forEach(player => {
                    const playerBadge = document.createElement('div');
                    playerBadge.className = 'player-badge';
                    playerBadge.textContent = player;
                    playersGrid.appendChild(playerBadge);
                });
            }
        }

        // Update player count
        function updatePlayerCount() {
            document.getElementById('player-count').textContent = players.length;
        }

        // Update start button state
        function updateStartButton() {
            const startBtn = document.getElementById('start-btn');
            if (players.length > 0 && !gameStarted) {
                startBtn.disabled = false;
                startBtn.textContent = 'Start Game';
            } else {
                startBtn.disabled = true;
                startBtn.textContent = players.length === 0 ? 'Start Game' : 'Loading...';
            }
        }

        // Start the game
        async function startGame() {
            try {
                // Fetch players from the players table
                const playerRows = await fetchPlayersFromTable(currentGameCode);
                const totalPlayers = playerRows.length;

                if (totalPlayers === 0) {
                    alert('No players have joined yet!');
                    return;
                }

                gameStarted = true;

                // Stop background music and play game start sound
                if (backgroundMusic && isMusicOn) {
                    backgroundMusic.pause();
                }
                if (gameStartSound) {
                    gameStartSound.currentTime = 0; // Reset to beginning
                    gameStartSound.play().catch(e => console.log('Game start sound blocked:', e));
                }

                // Synchronized start: set status to 'starting' and set start_time 5 seconds in the future
                const startTime = Date.now() + 10000; // 10 seconds from now
                let retries = 3;
                let lastError = null;
                let startTimeISO = new Date(startTime).toISOString();
                while (retries > 0) {
                    try {
                        console.log('ðŸ“¡ Sending game start update to database (synchronized start)...');
                        const result = await GameDB.updateGameSession(currentGameCode, {
                            status: 'starting',
                            start_time: startTimeISO
                        });
                        console.log('âœ… Game session updated successfully:', result);
                        break; // Success, exit retry loop
                    } catch (error) {
                        retries--;
                        lastError = error;
                        console.error(`âŒ Failed to update game session, retries left: ${retries}`, error);
                        console.error('Error details:', {
                            message: error.message,
                            code: error.code,
                            details: error.details,
                            hint: error.hint
                        });
                        if (retries === 0) {
                            // Disable start button and show error
                            const startBtn = document.getElementById('start-btn');
                            if (startBtn) {
                                startBtn.disabled = true;
                                startBtn.textContent = 'Error!';
                            }
                            alert('Failed to start game due to a database error. Please refresh and try again.');
                            throw error; // Re-throw if no retries left
                        }
                        await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
                    }
                }

                updateStartButton();

                // Immediately start the synchronized countdown for the host
                showSynchronizedCountdown(startTimeISO);
                // Also broadcast start immediately to connected players to reduce delay
                if (window.sendStartBroadcast) {
                    window.sendStartBroadcast(currentGameCode, startTimeISO);
                }
                
            } catch (error) {
                console.error('Error starting game:', error);
                gameStarted = false;
                updateStartButton();
                // Error alert already shown above
            }
        }

        // Register the gameSessionUpdated event listener at the top-level so it is always active
        window.addEventListener('gameSessionUpdated', onHostGameSessionUpdated);

        function onHostGameSessionUpdated(e) {
            const session = e.detail.session;
            if (session.status === 'starting' && session.start_time) {
                showSynchronizedCountdown(session.start_time);
            }
        }

        // Synchronized countdown function (ensure only one countdown runs)
        let hostSynchronizedCountdownInterval = null;
        function showSynchronizedCountdown(startTimeISO) {
            // Hide main container, header, player count, and controls ONLY when countdown actually begins
            document.querySelector('.main-container').style.display = 'none';
            document.querySelector('.header').style.display = 'none';
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            const countdownScreen = document.getElementById('quiz-countdown-screen');
            countdownScreen.classList.add('active');
            let countdown = QUIZ_CONFIG.previewCountdown; // configurable countdown time
            const countdownElement = document.getElementById('quiz-countdown');
            countdownElement.textContent = countdown;
            const startTimestamp = new Date(startTimeISO).getTime();
            const now = Date.now();
            let delay = Math.max(0, startTimestamp - now);
            if (hostSynchronizedCountdownInterval) {
                clearInterval(hostSynchronizedCountdownInterval);
                hostSynchronizedCountdownInterval = null;
            }
            hostSynchronizedCountdownInterval = setInterval(() => {
                const now2 = Date.now();
                const secondsLeft = Math.ceil((startTimestamp - now2) / 1000);
                countdownElement.textContent = Math.max(0, secondsLeft);
                // Switch to question preview when 5 seconds remain
                if (secondsLeft <= 5) {
                    clearInterval(hostSynchronizedCountdownInterval);
                    hostSynchronizedCountdownInterval = null;
                    countdownScreen.classList.remove('active');
                    // Start the 5s question preview leading into live question
                    const remaining = Math.max(0, secondsLeft);
                    showQuestionPreview(Math.max(remaining, 5));
                }
            }, 250);
        }

        // Show question preview screen
        async function showQuestionPreview(durationSeconds = 5) {
            const previewScreen = document.getElementById('question-preview-screen');
            const question = quizQuestions[currentQuestionIndex];
            
            // Update question content
            previewScreen.querySelector('.quiz-title').textContent = question.title;
            previewScreen.querySelector('.question-counter').textContent = `${currentQuestionIndex + 1}/${quizQuestions.length}`;
            previewScreen.querySelector('.question-image').src = question.image;
            
            // Ensure player count and controls are hidden during question preview
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            
            previewScreen.classList.add('active');
            
            let previewCountdown = durationSeconds;
            // Compute a precise live start timestamp shared with players
            const liveStartTs = Date.now() + (durationSeconds * 1000);
            const liveStartISO = new Date(liveStartTs).toISOString();
            
            // Start preview timer bar animation
            const timerBar = document.getElementById('preview-timer-bar');
            timerBar.style.width = '100%';
            timerBar.style.transitionDuration = `${durationSeconds}s`;
            
            setTimeout(() => {
                timerBar.style.width = '0%';
            }, 100);
            
            // Update quiz state for players (include precise live start time)
            await GameDB.updateQuizState(currentGameCode, {
                phase: 'question-preview',
                currentQuestion: currentQuestionIndex,
                questionData: { ...question, liveStartISO, totalQuestions: quizQuestions.length },
                countdown: previewCountdown
            });
            
            const previewInterval = setInterval(async () => {
                previewCountdown--;
                console.log('ðŸ• Preview countdown:', previewCountdown);
                
                if (previewCountdown > 0) {
                    // Update countdown for players
                    await GameDB.updateQuizState(currentGameCode, {
                        phase: 'question-preview',
                        currentQuestion: currentQuestionIndex,
                        questionData: { ...question, liveStartISO, totalQuestions: quizQuestions.length },
                        countdown: previewCountdown
                    });
                } else {
                    console.log('ðŸŽ¯ Preview countdown finished! Transitioning to live question...');
                    clearInterval(previewInterval);
                    previewScreen.classList.remove('active');
                    
                    // Calculate delay for precise timing, but cap it at 2 seconds max to prevent hanging
                    const delayMs = Math.max(0, Math.min(2000, liveStartTs - Date.now()));
                    console.log('â° Calculated delay for live start:', delayMs, 'ms');
                    
                    if (delayMs > 0) {
                        setTimeout(() => {
                            console.log('ðŸš€ Starting live question via timeout...');
                            showLiveQuestion();
                        }, delayMs);
                    } else {
                        // Start immediately if delay is 0 or negative
                        console.log('ðŸš€ Starting live question immediately...');
                        showLiveQuestion();
                    }
                    
                    // Fallback: ensure live question starts within 3 seconds no matter what
                    setTimeout(() => {
                        console.log('ðŸ”„ Fallback check: ensuring live question started...');
                        const currentActiveScreen = document.querySelector('.quiz-screen.active');
                        if (currentActiveScreen && currentActiveScreen.id !== 'live-question-screen') {
                            console.warn('ðŸš¨ Live question not active, forcing transition!');
                            showLiveQuestion();
                        }
                    }, 3000);
                }
            }, 1000);
        }

        // Show live question screen
        async function showLiveQuestion() {
            const liveScreen = document.getElementById('live-question-screen');
            const question = quizQuestions[currentQuestionIndex];
            
            // Update question content
            liveScreen.querySelector('.quiz-title').textContent = question.title;
            liveScreen.querySelector('.question-counter').textContent = `${currentQuestionIndex + 1}/${quizQuestions.length}`;
            liveScreen.querySelector('.question-image').src = question.image;
            
            // Update answer options
            const optionTexts = liveScreen.querySelectorAll('.option-text');
            optionTexts[0].textContent = question.options[0]; // A
            optionTexts[1].textContent = question.options[1]; // B
            optionTexts[2].textContent = question.options[2]; // C
            optionTexts[3].textContent = question.options[3]; // D
            
            // Ensure player count and controls are hidden during live question
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            
            liveScreen.classList.add('active');
            // Mark game started when the question goes live
            try { await GameDB.updateGameSession(currentGameCode, { status: 'started' }); } catch (e) { console.warn('Failed to set started status:', e); }
            
            // Update quiz state for players
            await GameDB.updateQuizState(currentGameCode, {
                phase: 'live-question',
                currentQuestion: currentQuestionIndex,
                questionData: { ...question, totalQuestions: quizQuestions.length },
                timeLeft: QUIZ_CONFIG.questionTimeLimit
            });
            
            // Start question timer (configurable seconds for answering)
            let questionTime = QUIZ_CONFIG.questionTimeLimit;
            const timerElement = document.getElementById('question-timer');
            timerElement.textContent = questionTime;
            
            questionTimer = setInterval(async () => {
                questionTime--;
                if (questionTime > 0) {
                    timerElement.textContent = questionTime;
                    
                    // Play last countdown sound when 10 seconds remain
                    if (questionTime === 10 && lastCountdownSound) {
                        lastCountdownSound.currentTime = 0; // Reset to beginning
                        lastCountdownSound.play().catch(e => console.log('Last countdown sound blocked:', e));
                    }
                } else {
                    // Play time's up sound
                    if (timesUpSound) {
                        timesUpSound.currentTime = 0; // Reset to beginning
                        timesUpSound.play().catch(e => console.log('Times up sound blocked:', e));
                    }
                    
                    clearInterval(questionTimer);
                    liveScreen.classList.remove('active');
                    showQuestionResults();
                }
            }, 1000);
        }

        // Show question results
        async function showQuestionResults() {
            const resultsScreen = document.getElementById('quiz-results-screen');
            const question = quizQuestions[currentQuestionIndex];
            
            // Update quiz title with current question number
            const quizTitle = resultsScreen.querySelector('.quiz-title');
            if (quizTitle) {
                quizTitle.textContent = `Question ${currentQuestionIndex + 1}`;
                console.log('ðŸŽ¯ Updated host quiz title to:', `Question ${currentQuestionIndex + 1}`);
            }
            
            // Get answers from Supabase
            const answers = await GameDB.getQuestionAnswers(currentGameCode, currentQuestionIndex);
            
            // Count answers
            const answerCounts = [0, 0, 0, 0]; // A, B, C, D
            answers.forEach(answer => {
                const index = answer.answer.charCodeAt(0) - 65; // Convert A=0, B=1, etc.
                if (index >= 0 && index < 4) {
                    answerCounts[index]++;
                }
            });
            
            // Update answer bars
            const maxCount = Math.max(...answerCounts, 1);
            ['a', 'b', 'c', 'd'].forEach((letter, index) => {
                const count = answerCounts[index];
                const barElement = document.getElementById(`answer-${letter}-bar`);
                const countElement = document.getElementById(`answer-${letter}-count`);
                
                if (barElement && countElement) {
                    const percentage = maxCount > 0 ? (count / maxCount) * 100 : 0;
                    barElement.style.height = `${percentage}%`;
                    countElement.textContent = count;
                }
            });
            
            // Update answer options with correct answer highlighting
            ['a', 'b', 'c', 'd'].forEach((letter, index) => {
                const optionElement = document.getElementById(`result-option-${letter}`);
                const textElement = document.getElementById(`result-option-text-${letter}`);
                
                if (optionElement && textElement) {
                    textElement.textContent = question.options[index];
                    
                    if (index === question.correct) {
                        optionElement.classList.add('correct');
                    } else {
                        optionElement.classList.remove('correct');
                    }
                }
            });
            
            // Ensure player count and controls are hidden during results
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            
            resultsScreen.classList.add('active');

            // Calculate and persist player scores (Kahoot-like scoring 500â€“1000)
            try {
                // Map player_id -> name
                const { data: playerRows } = await window.supabaseClient
                    .from('players')
                    .select('player_id, name')
                    .eq('game_code', currentGameCode);
                const idToName = (playerRows || []).reduce((acc, r) => { acc[r.player_id] = r.name; return acc; }, {});
                
                // Build score updates per name
                const questionTimeLimit = QUIZ_CONFIG.questionTimeLimit;
                const session = await GameDB.getGameSession(currentGameCode);
                const scores = session?.scores || {};
                
                // Create a set of players who answered this question
                const answeredPlayers = new Set();
                
                // Process submitted answers
                answers.forEach(a => {
                    const name = idToName[a.player_id];
                    if (!name) return;
                    answeredPlayers.add(name);
                    
                    const idx = ['A','B','C','D'].indexOf(a.answer);
                    const isCorrect = idx === question.correct;
                    let points = 0;
                    if (isCorrect) {
                        if (QUIZ_CONFIG.pointsConfig.timeBonus) {
                            const t = Math.min(Number(a.time_taken || 0), questionTimeLimit);
                            const basePoints = QUIZ_CONFIG.pointsConfig.minPoints;
                            const bonusPoints = QUIZ_CONFIG.pointsConfig.maxPoints - QUIZ_CONFIG.pointsConfig.minPoints;
                            points = Math.max(basePoints, Math.min(QUIZ_CONFIG.pointsConfig.maxPoints, 
                                Math.round((1 - (t / questionTimeLimit)) * bonusPoints + basePoints)));
                        } else {
                            points = QUIZ_CONFIG.pointsConfig.maxPoints;
                        }
                    }
                    scores[name] = (scores[name] || 0) + points;
                });
                
                // Handle players who didn't answer - mark as wrong and give 0 points
                Object.values(idToName).forEach(playerName => {
                    if (!answeredPlayers.has(playerName)) {
                        console.log(`â° Player ${playerName} didn't answer - marking as wrong with 0 points`);
                        scores[playerName] = (scores[playerName] || 0) + 0; // 0 points for no answer
                        
                        // Create a dummy answer record for unanswered players so they can see results
                        // This ensures all players transition to results page
                        GameDB.submitAnswer(currentGameCode, 'unanswered', currentQuestionIndex, 'X', questionTimeLimit)
                            .catch(e => console.warn('Failed to create dummy answer for unanswered player:', e));
                    }
                });
                
                await GameDB.updateGameSession(currentGameCode, { scores });
                console.log(`âœ… Processed scores for ${Object.keys(scores).length} players (including unanswered)`);
            } catch (e) {
                console.warn('Failed to persist scores:', e);
            }

            // Update quiz state for players; include question data so clients can compute their result text
            await GameDB.updateQuizState(currentGameCode, {
                phase: 'results',
                currentQuestion: currentQuestionIndex,
                questionData: { ...question, totalQuestions: quizQuestions.length }
            });
        }

        // Show scoreboard screen
        async function showScoreboard() {
            document.getElementById('quiz-results-screen').classList.remove('active');
            
            const scoreboardScreen = document.getElementById('scoreboard-screen');
            
            // Update quiz state for players
            await GameDB.updateQuizState(currentGameCode, {
                phase: 'scoreboard',
                currentQuestion: currentQuestionIndex
            });
            
            // Update player scores
            updatePlayerScores();
            
            // Ensure player count and controls are hidden during scoreboard
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            
            scoreboardScreen.classList.add('active');
        }

        // Update player scores (fetch players from players table, scores from game_sessions)
        async function updatePlayerScores() {
            try {
                const [session, playerRows] = await Promise.all([
                    GameDB.getGameSession(currentGameCode),
                    fetchPlayersFromTable(currentGameCode)
                ]);

                const scores = (session && session.scores) || {};
                const playerNames = (playerRows || []).map(p => p.name);

                const playerScores = playerNames.map(name => ({
                    name,
                    score: scores[name] || 0
                })).sort((a, b) => b.score - a.score);

                const playerScoresContainer = document.getElementById('player-scores');
                playerScoresContainer.innerHTML = '';

                if (playerScores.length === 0) {
                    playerScoresContainer.innerHTML = '<div class="no-scores">No player scores available</div>';
                    return;
                }

                playerScores.forEach((player, index) => {
                    const scoreItem = document.createElement('div');
                    scoreItem.className = `score-item rank-${index + 1}`;

                    let medalIcon = '';
                    if (index === 0) {
                        medalIcon = '<img src="assets/medal_1.png" alt="Gold Medal" class="medal-icon">';
                    } else if (index === 1) {
                        medalIcon = '<img src="assets/medal_2.png" alt="Silver Medal" class="medal-icon">';
                    } else if (index === 2) {
                        medalIcon = '<img src="assets/medal_3.png" alt="Bronze Medal" class="medal-icon">';
                    }

                    scoreItem.innerHTML = `
                        ${medalIcon}
                        <span class="player-name">${player.name}</span>
                        <span class="player-score">${player.score}</span>
                    `;

                    playerScoresContainer.appendChild(scoreItem);
                });
            } catch (error) {
                console.error('Error updating player scores:', error);
            }
        }

        // Proceed to next question
        async function proceedToNextQuestion() {
            document.getElementById('scoreboard-screen').classList.remove('active');
            
            currentQuestionIndex++;
            
            if (currentQuestionIndex < quizQuestions.length) {
                // IMMEDIATELY notify players of the transition
                console.log('ðŸš€ Host proceeding to next question. Immediately notifying players...');
                
                // 1. Broadcast immediate transition signal
                try {
                    await broadcastNextQuestion(currentQuestionIndex);
                } catch (e) {
                    console.warn('Failed to broadcast next question:', e);
                }
                
                // 2. Update game session with next question signal
                try {
                    await GameDB.updateGameSession(currentGameCode, {
                        next_question_signal: currentQuestionIndex,
                        updated_at: new Date().toISOString()
                    });
                } catch (e) {
                    console.warn('Failed to update game session with next question signal:', e);
                }
                
                // 3. Start the countdown as normal
                await startNextQuestionCountdown();
            } else {
                // Quiz ended - show final leaderboard
                showFinalLeaderboard();
            }
        }

        // Start 10-second countdown before next question
        async function startNextQuestionCountdown() {
            // For next questions, go directly to question preview with 10-second countdown
            // (Generic countdown screen is only for the very first question)
            
            // IMMEDIATELY update quiz state to ensure players get notified
            try {
                console.log('ðŸ”„ Updating quiz state for next question transition...');
                await GameDB.updateQuizState(currentGameCode, {
                    phase: 'question-preview',
                    currentQuestion: currentQuestionIndex,
                    questionData: { ...quizQuestions[currentQuestionIndex], totalQuestions: quizQuestions.length },
                    countdown: 10
                });
                console.log('âœ… Quiz state updated for next question');
            } catch (error) {
                console.error('âŒ Failed to update quiz state for next question:', error);
            }
            
            showQuestionPreview(10);
        }

        // Show final leaderboard with celebration
        async function showFinalLeaderboard() {
            document.getElementById('scoreboard-screen').classList.remove('active');
            
            const finalScreen = document.getElementById('final-leaderboard-screen');
            
            // IMMEDIATELY broadcast final results transition to players
            try {
                await broadcastFinalResults();
            } catch (e) {
                console.warn('Failed to broadcast final results:', e);
            }
            
            // Update quiz state for players
            await GameDB.updateQuizState(currentGameCode, {
                phase: 'final-results'
            });
            
            // Ensure player count and controls are hidden during final leaderboard
            document.getElementById('player-count-container').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            
            finalScreen.classList.add('active');
            
            // Play crowds sound effect for celebration
            if (crowdsSound) {
                crowdsSound.currentTime = 0; // Reset to beginning
                crowdsSound.play().catch(e => console.log('Crowds sound blocked:', e));
            }
            
            // Start confetti animation
            createConfetti();
            
            // Update final scores
            updateFinalPodium();
        }

        // Broadcast next question signal to players
        async function broadcastNextQuestion(questionIndex) {
            console.log('ðŸ“¡ Broadcasting next question signal to players:', questionIndex);
            console.log('ðŸ“¡ Using game code:', currentGameCode);
            
            // Use Supabase broadcast channel for immediate communication
            try {
                const channelName = `next_question_${currentGameCode}`;
                console.log('ðŸ“¡ Creating broadcast channel:', channelName);
                
                const channel = window.supabaseClient.channel(channelName, { 
                    config: { broadcast: { self: true } } 
                });
                
                await channel.subscribe((status) => {
                    console.log('ðŸ“¡ Next question broadcast channel status:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('âœ… Broadcast channel subscribed successfully');
                    }
                });
                
                const payload = {
                    game_code: currentGameCode,
                    question_index: questionIndex,
                    timestamp: Date.now()
                };
                
                console.log('ðŸ“¡ Sending broadcast payload:', payload);
                
                await channel.send({
                    type: 'broadcast',
                    event: 'next_question',
                    payload: payload
                });
                
                console.log('âœ… Next question broadcast sent successfully');
                console.log('ðŸ“¡ Players should now receive the signal and transition to countdown');
                
                // Clean up channel after a short delay
                setTimeout(() => {
                    console.log('ðŸ§¹ Cleaning up broadcast channel');
                    window.supabaseClient.removeChannel(channel);
                }, 2000);
                
            } catch (error) {
                console.error('âŒ Failed to broadcast next question:', error);
                console.error('âŒ Error details:', error.message, error.stack);
                throw error;
            }
        }

        // Broadcast final results signal to players
        async function broadcastFinalResults() {
            console.log('ðŸ“¡ Broadcasting final results signal to players');
            console.log('ðŸ“¡ Using game code:', currentGameCode);
            
            // Use Supabase broadcast channel for immediate communication
            try {
                const channelName = `final_results_${currentGameCode}`;
                console.log('ðŸ“¡ Creating broadcast channel:', channelName);
                
                const channel = window.supabaseClient.channel(channelName, { 
                    config: { broadcast: { self: true } } 
                });
                
                await channel.subscribe((status) => {
                    console.log('ðŸ“¡ Final results broadcast channel status:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('âœ… Final results broadcast channel subscribed successfully');
                    }
                });
                
                const payload = {
                    game_code: currentGameCode,
                    timestamp: Date.now()
                };
                
                console.log('ðŸ“¡ Sending final results broadcast payload:', payload);
                
                await channel.send({
                    type: 'broadcast',
                    event: 'final_results',
                    payload: payload
                });
                
                console.log('âœ… Final results broadcast sent successfully');
                console.log('ðŸ“¡ Players should now receive the signal and transition to final results');
                
                // Clean up channel after a short delay
                setTimeout(() => {
                    console.log('ðŸ§¹ Cleaning up final results broadcast channel');
                    window.supabaseClient.removeChannel(channel);
                }, 2000);
                
            } catch (error) {
                console.error('âŒ Failed to broadcast final results:', error);
                console.error('âŒ Error details:', error.message, error.stack);
                throw error;
            }
        }

        // Create confetti animation
        function createConfetti() {
            const duration = 15000; // 15 seconds
            const animationEnd = Date.now() + duration;
            const defaults = {
                startVelocity: 30,
                spread: 360,
                ticks: 100,
                zIndex: 9999
            };

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            const interval = setInterval(function() {
                if (Date.now() > animationEnd) {
                    return clearInterval(interval);
                }

                confetti(Object.assign({}, defaults, {
                    particleCount: 5,
                    origin: {
                        x: Math.random(),
                        y: -0.1
                    },
                    colors: ['#ff595e', '#ffca3a', '#8ac926', '#1982c4', '#6a4c93']
                }));
            }, 250);
        }

        // Update final podium with top 3 players
        async function updateFinalPodium() {
            try {
                console.log('ðŸ† Updating final podium for game:', currentGameCode);
                
                // Get both session data (for scores) and player data
                const [session, playerRows] = await Promise.all([
                    GameDB.getGameSession(currentGameCode),
                    fetchPlayersFromTable(currentGameCode)
                ]);
                
                console.log('ðŸ“Š Session data:', session);
                console.log('ðŸ‘¥ Player rows:', playerRows);
                
                let finalScores = [];
                
                if (session && session.scores && playerRows && playerRows.length > 0) {
                    // Create final scores array from players table and session scores
                    finalScores = playerRows.map(player => {
                        const score = session.scores[player.name] || 0;
                        console.log(`ðŸ“ˆ Player ${player.name}: ${score} points`);
                        return {
                            name: player.name,
                            score: score
                        };
                    }).sort((a, b) => b.score - a.score).slice(0, 3);
                    
                    console.log('ðŸŽ¯ Final scores (top 3):', finalScores);
                } else {
                    console.warn('âš ï¸ Missing session scores or player data');
                    console.log('Session scores:', session?.scores);
                    console.log('Player rows:', playerRows);
                }
                
                // Default empty podium if no players
                const defaultPlayers = [
                    { name: '-', score: 0 },
                    { name: '-', score: 0 },
                    { name: '-', score: 0 }
                ];
                
                // Fill missing positions with default values
                while (finalScores.length < 3) {
                    finalScores.push(defaultPlayers[finalScores.length]);
                }
                
                console.log('ðŸ… Final podium data:', finalScores);
                
                // Update winner (1st place)
                const firstPlace = document.querySelector('.first-place');
                if (firstPlace) {
                    firstPlace.querySelector('.podium-name').textContent = finalScores[0].name;
                    firstPlace.querySelector('.podium-score').textContent = finalScores[0].score;
                    console.log('ðŸ¥‡ 1st place updated:', finalScores[0]);
                }
                
                // Update 2nd place
                const secondPlace = document.querySelector('.second-place');
                if (secondPlace) {
                    secondPlace.querySelector('.podium-name').textContent = finalScores[1].name;
                    secondPlace.querySelector('.podium-score').textContent = finalScores[1].score;
                    console.log('ðŸ¥ˆ 2nd place updated:', finalScores[1]);
                }
                
                // Update 3rd place
                const thirdPlace = document.querySelector('.third-place');
                if (thirdPlace) {
                    thirdPlace.querySelector('.podium-name').textContent = finalScores[2].name;
                    thirdPlace.querySelector('.podium-score').textContent = finalScores[2].score;
                    console.log('ðŸ¥‰ 3rd place updated:', finalScores[2]);
                }
                
                console.log('âœ… Final podium update complete!');
            } catch (error) {
                console.error('âŒ Error updating final podium:', error);
            }
        }

        // Play again function
        async function playAgain() {
            document.getElementById('final-leaderboard-screen').classList.remove('active');
            
            console.log('ðŸ”„ Play Again: Starting fresh game...');
            
            try {
                // Clean up current game completely (remove all players and data)
                console.log('ðŸ§¹ Cleaning up current game:', currentGameCode);
                await GameDB.cleanupExistingGame(currentGameCode);
                
                // Clean up subscriptions for the old game
                cleanupSubscriptions();
                cleanupReactionSystem();
                
                // Reset all game state
                players = [];
                gameStarted = false;
                currentQuestionIndex = 0;
                
                // Force immediate UI update to show no players
                console.log('ðŸ”„ Updating UI to show no players...');
                updatePlayersDisplay();
                updatePlayerCount();
                updateStartButton();
                
                // Generate a new game code and create new session
                console.log('ðŸŽ® Generating new game code...');
                await generateGameCode();
                
                // Reinitialize reaction system for new game
                initializeReactionSystem(currentGameCode);
                
                // Reset to waiting room with new game
                resetToWaitingRoom();
                
                // Ensure player count and controls are visible in new game
                document.getElementById('player-count-container').style.display = 'block';
                document.getElementById('controls-container').style.display = 'block';
                
                console.log('âœ… New game created with code:', currentGameCode);
                
            } catch (error) {
                console.error('âŒ Error creating new game:', error);
                alert('Error creating new game. Please refresh the page.');
            }
        }

        // Reset back to waiting room
        async function resetToWaitingRoom() {
            document.querySelectorAll('.quiz-screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            document.querySelector('.main-container').style.display = 'flex';
            document.querySelector('.header').style.display = 'flex';
            document.getElementById('player-count-container').style.display = 'block';
            document.getElementById('controls-container').style.display = 'block';
            
            gameStarted = false;
            currentQuestionIndex = 0;
            
            // Clear player scores from session
            try {
                await GameDB.updateGameSession(currentGameCode, {
                    scores: {},
                    status: 'waiting'
                });
            } catch (error) {
                console.error('Error resetting game session:', error);
            }
            
            // Update UI to show no players
            updatePlayersDisplay();
            updatePlayerCount();
            updateStartButton();
        }

        // Initialize music with default soundtrack
        function initializeMusic() {
            backgroundMusic = new Audio('assets/soundtrack/Answer That Now!.mp3');
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.5;
            
            // Load saved music state from localStorage (default to off)
            const savedMusicState = localStorage.getItem('quitize_music_on');
            if (savedMusicState !== null) {
                isMusicOn = savedMusicState === 'true';
            } else {
                // Default to music off for first-time users
                isMusicOn = false;
            }
            
            // Update icon to reflect current state (default to music off)
            if (!isMusicOn) {
                document.getElementById('music-icon').src = 'assets/music_off.png';
            } else {
                document.getElementById('music-icon').src = 'assets/music_on.png';
                document.getElementById('music-icon').classList.add('playing');
            }
            
            // Start playing music only if it was previously turned on
            if (isMusicOn) {
                backgroundMusic.play().catch(e => console.log('Music autoplay blocked:', e));
            }
        }

        // Initialize sound effects
        function initializeSoundEffects() {
            gameStartSound = new Audio('assets/soundeffect/gamestart.mp3');
            lastCountdownSound = new Audio('assets/soundeffect/lastcountdown.MP3');
            timesUpSound = new Audio('assets/soundeffect/timesup.mp3');
            crowdsSound = new Audio('assets/soundeffect/crowds.mp3');
            
            // Set volumes
            gameStartSound.volume = 0.7;
            lastCountdownSound.volume = 0.8;
            timesUpSound.volume = 0.8;
            crowdsSound.volume = 0.6;
        }

        // Toggle music on/off
        function toggleMusic() {
            const musicIcon = document.getElementById('music-icon');
            
            if (isMusicOn) {
                backgroundMusic.pause();
                musicIcon.src = 'assets/music_off.png';
                musicIcon.classList.remove('playing');
                isMusicOn = false;
                // Save music state to localStorage
                localStorage.setItem('quitize_music_on', 'false');
            } else {
                backgroundMusic.play();
                musicIcon.src = 'assets/music_on.png';
                musicIcon.classList.add('playing');
                isMusicOn = true;
                // Save music state to localStorage
                localStorage.setItem('quitize_music_on', 'true');
            }
        }

        // Toggle fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Error attempting to enable fullscreen:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Initialize controls event listeners
        function initializeControls() {
            // Music toggle
            document.getElementById('music-icon').addEventListener('click', toggleMusic);
            
            // Fullscreen toggle
            document.querySelector('.fullscreen-icon').addEventListener('click', toggleFullscreen);
        }

        // Live Reaction System
        let reactionChannel = null;
        let activeReactions = 0;
        const MAX_ACTIVE_REACTIONS = 50; // Limit simultaneous floating reactions for performance
        
        function initializeReactionSystem(gameCode) {
            console.log('ðŸŽ‰ Initializing reaction system for game:', gameCode);
            
            if (reactionChannel) {
                window.supabaseClient.removeChannel(reactionChannel);
            }
            
            const channelName = `reactions_${gameCode}`;
            reactionChannel = window.supabaseClient.channel(channelName, {
                config: { broadcast: { self: false } }
            });
            
            reactionChannel.on('broadcast', { event: 'reaction' }, (payload) => {
                console.log('ðŸŽ‰ Received reaction:', payload.payload);
                handleReaction(payload.payload);
            });
            
            reactionChannel.subscribe((status) => {
                console.log('ðŸŽ‰ Reaction channel status:', status);
            });
        }
        
        function handleReaction(reactionData) {
            const { emoji, playerName, burst } = reactionData;
            createFloatingReaction(emoji, burst);
            console.log(`ðŸŽ‰ ${playerName} sent ${emoji}${burst ? ' (burst!)' : ''}`);
        }
        
        function getReactionImagePath(reactionType) {
            const reactionMap = {
                'clap': 'assets/livereaction/clap.png',
                'heart': 'assets/livereaction/heart.png',
                'confetti': 'assets/livereaction/confetti.png'
            };
            return reactionMap[reactionType] || 'assets/livereaction/clap.png';
        }
        
        function createFloatingReaction(reactionType, isBurst = false) {
            // Performance optimization: limit active reactions
            if (activeReactions >= MAX_ACTIVE_REACTIONS) {
                console.log('Max reactions reached, skipping');
                return;
            }
            
            const reactionsDisplay = document.getElementById('reactions-display');
            if (!reactionsDisplay) return;
            
            activeReactions++;
            
            const reaction = document.createElement('div');
            reaction.className = `floating-reaction${isBurst ? ' burst' : ''}`;
            
            // Create image element for the reaction
            const img = document.createElement('img');
            img.src = getReactionImagePath(reactionType);
            img.alt = reactionType;
            img.className = 'floating-reaction-image';
            reaction.appendChild(img);
            
            // Position reaction at bottom left area (near player count)
            const startX = Math.random() * 300 + 50; // Random X between 50-350px from left
            const startY = window.innerHeight - 100; // Start near bottom
            
            reaction.style.left = startX + 'px';
            reaction.style.top = startY + 'px';
            
            // Add random horizontal drift
            const drift = (Math.random() - 0.5) * 200;
            reaction.style.setProperty('--drift', drift + 'px');
            
            reactionsDisplay.appendChild(reaction);
            
            // Remove reaction after animation completes
            const duration = isBurst ? 2500 : 3000;
            setTimeout(() => {
                if (reaction.parentNode) {
                    reaction.parentNode.removeChild(reaction);
                    activeReactions = Math.max(0, activeReactions - 1);
                }
            }, duration);
        }
        
        // Clean up reaction system
        function cleanupReactionSystem() {
            if (reactionChannel) {
                window.supabaseClient.removeChannel(reactionChannel);
                reactionChannel = null;
            }
        }



        // Initialize the game
        async function initializeGame() {
            try {
                // Clean up old games first
                await GameDB.cleanupOldGames();
                
                await generateGameCode();
                updatePlayersDisplay();
                updatePlayerCount();
                updateStartButton();
                
                // Initialize reaction system
                initializeReactionSystem(currentGameCode);
                
                // Start listening for players joining
                startPlayerListener();
                // Periodic refresh for player list (fallback for real-time)
                setInterval(updatePlayerListFromSession, 3000);
                
                // Initialize music, sound effects and controls
                initializeMusic();
                initializeSoundEffects();
                initializeControls();
            } catch (error) {
                console.error('Error during game initialization:', error);
                alert('Failed to initialize game. Please refresh the page and try again.');
            }
        }

        // Handle keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' || event.key === ' ') {
                if (!document.getElementById('start-btn').disabled) {
                    startGame();
                }
            }
            
            // Music toggle with 'M' key
            if (event.key.toLowerCase() === 'm') {
                toggleMusic();
            }
            
            // Fullscreen toggle with 'F' key
            if (event.key.toLowerCase() === 'f') {
                toggleFullscreen();
            }
            

        });

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            cleanupSubscriptions();
        });

        // Initialize when page loads
        window.addEventListener('load', initializeGame);
    </script>
</body>
</html> 